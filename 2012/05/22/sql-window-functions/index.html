<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta content='Please, never say &amp;quot;widgets&amp;quot; in my presence again.' name='description'>
<meta content='IE=edge;chrome=1' http-equiv='X-UA-Compatible'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<meta content='True' name='HandheldFriendly'>
<meta content='320' name='MobileOptimized'>
<link href='/favicon.png' rel='icon'>
<title>Awkward and Proud - Joshua Davey</title>
<link href="/stylesheets/screen.css" rel="stylesheet" type="text/css" />
<link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/atom.xml" />
<script src='https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js'></script>
<script src='/javascripts/main.js'></script>
</head>
<body>
<div id='content'>
<header>
<h1><a href="/">Awkward and Proud</a></h1>
</header>
<div id='description'>
<ul class='meta'>
<li>
<a href="/about">About</a>
/
<a href="/atom.xml">RSS</a>
</li>
</ul>
</div>
<div id='main'><div class='post'>
<div class='post-body'>
<h2>SQL Window Functions and You</h2>
<p><em>This is a repost. You can find the original <a title="SQL Window Functions and You" href="http://hashrocket.com/blog/posts/sql-window-functions">here</a></em></p>

<p>Suppose you have a storefront application that sells pictures of cats.
These cat pictures are categorized in meaningful ways. For example,
there are LOLcats pictures and &ldquo;Classic&rdquo; cat pictures. Now, on the
landing page of the store, you&rsquo;d like to feature one picture from each
category. It can&rsquo;t be a random picture from each. You need to feature
the cheapest picture from each category, displaying its name and price.</p>

<p>Also, it turns out that some &ldquo;low&rdquo; prices are very common. For example,
$9.99 is a common sale price for LOLcats pictures. However, we should
only ever feature one picture per category. When there are multiple
pictures with the same low price, we fallback to the name, and show the
first one alphabetically. How can we solve this problem, while also
remaining performant?</p>

<p>As an aside, adding a cat to a Rennaisance painting amplifies its appeal
ninefold.</p>

<p><img alt="catpictures.biz" src="https://s3.amazonaws.com/hashrocket-blog-production/catpictures.com.jpg" /></p>

<p>Let&rsquo;s look at some of the ways that we can approach this problem,
displaying a list of cat pictures that are the cheapest for their
respective category.</p>

<h2>Approach 1: Ruby</h2>

<p>Implementing the solution in Ruby is fairly straightforward.
<del>ActiveSupport</del> Enumerable provides the <code>group_by</code> and <code>sort_by</code> methods on
collections, and we can use those to help us cut down on some typing.</p>
<pre class="highlight ruby"><span class="k">class</span> <span class="nc">CatPicture</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:category_id</span><span class="p">,</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:price</span>
  <span class="n">belongs_to</span> <span class="ss">:category</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">cheapest_per_category</span>
    <span class="n">all</span><span class="p">.</span><span class="nf">group_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:category_id</span><span class="p">).</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">category_id</span><span class="p">,</span> <span class="n">subset</span><span class="o">|</span>
      <span class="n">subset</span><span class="p">.</span><span class="nf">sort_by</span> <span class="p">{</span> <span class="o">|</span><span class="n">pic</span><span class="o">|</span> <span class="o">[</span><span class="n">pic</span><span class="p">.</span><span class="nf">price</span><span class="p">,</span> <span class="n">pic</span><span class="p">.</span><span class="nf">name</span><span class="o">]</span> <span class="p">}.</span><span class="nf">first</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

<p>First, we group all of the cat pictures by their category. Then, for
each set of pictures, we sort them by their price and name, and take
only the first one.</p>

<p>Perhaps you are wondering if inverting the responsibility would improve
the implementation, putting the mapping and reduction impetus in the
Category model instead. Although it would be possible to go through
the Category model to find its cheapest picture, that would lead to an
&ldquo;n+1&rdquo;, as each category would subsequently need fetch its cat pictures.
Alternatively, eager-loading all categories with their cat pictures
would be expensive, and would essentially duplicate what we&rsquo;ve done
above with the <code>group_by</code>.</p>

<p>Either way, as you can probably imagine, the above method would become
more expensive as the data set continued to grow. Additionally, we lose
the ability to continue to chain ActiveRecord scopes to filter the set
further: as soon as we fetch the collection from the database, all
filtering has to be done in Ruby.</p>

<p>Pros:</p>

<ul>
<li>Easy to grok</li>
<li>All domain logic stays in application</li>
</ul>

<p>Cons:</p>

<ul>
<li>Expensive (all objects loaded into memory)</li>
<li>No scope chaining</li>
<li>Once you go Ruby, you don&rsquo;t go back</li>
</ul>

<h2>Approach 2: SQL subselects</h2>

<p>We can improve performance by doing the filtering at the database level,
rather than loading all cat pictures into memory each time.</p>
<pre class="highlight ruby"><span class="k">class</span> <span class="nc">CatPicture</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:category_id</span><span class="p">,</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:price</span>
  <span class="n">belongs_to</span> <span class="ss">:category</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">cheapest_per_category</span>
    <span class="n">find_by_sql</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      SELECT DISTINCT ON(category_id) cat_pictures.*
      FROM cat_pictures
      WHERE ((category_id, price) IN (
        SELECT category_id, min(price)
        FROM cat_pictures
        GROUP BY category_id
      ))
      ORDER BY category_id ASC, cat_pictures.name ASC
</span><span class="no">    SQL</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

<p>Here, we use a subselect to filter the initial set down to only those
that have the cheapest price per category. In this inner query, each row
will contain a <code>category_id</code> and its lowest <code>price</code>. In the outer query,
we choose all cat pictures whose <code>price</code> and <code>category_id</code> match a row
from this inner query, using the <code>IN</code> syntax.</p>

<p>We would be done here, except that there still exists the possibility
that there could be more than one that have that low price for a given
category. So, depending on the database vendor, we can here find
&ldquo;distinct&rdquo; rows, according the columns of interest. In Postgresql,
the syntax for this is <code>DISTINCT ON([column,...])</code>, which will omit
duplicates of the listed columns. For our purposes, we don&rsquo;t want more
than one per category, so we distinct on <code>category_id</code>.</p>

<p>It is worth noting that without an <code>ORDER BY</code> clause, <code>DISTINCT ON</code> is
nondeterministic: we are not guaranteed to get the same result each
time. Thus, we order by <code>category_id</code> and <code>name</code>, so that only the first
cat picture alphabetically will show up.</p>

<p>We can improve the implementation above by making it a true chainable
scope. Whereas <code>find_by_sql</code> returns an array of objects, we can
refactor this to return an ActiveRelation instead.</p>
<pre class="highlight ruby"><span class="k">class</span> <span class="nc">CatPicture</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:category_id</span><span class="p">,</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:price</span>
  <span class="n">belongs_to</span> <span class="ss">:category</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">cheapest_per_category</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"(category_id, price) IN (</span><span class="si">#{</span><span class="n">category_id_and_lowest_price_sql</span><span class="si">}</span><span class="s2">)"</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="s2">"DISTINCT ON(category_id) </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">.*"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"category_id ASC, </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">.name ASC"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">category_id_and_lowest_price_sql</span>
    <span class="n">scoped</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"category_id, min(price)"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:category_id</span><span class="p">).</span><span class="nf">to_sql</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

<p>Functionally, this generates the exact same query as before, but allows
further chaining. Using ActiveRelation&rsquo;s <code>to_sql</code> method, we&rsquo;re able
to build up our inner query without actually executing it. We then
interpolate that query into what was the outer query, which we&rsquo;ve
reduced to calls to <code>where</code>, <code>select</code> and <code>order</code>.</p>

<p>Pros:</p>

<ul>
<li>More performant than Ruby method</li>
<li>Scope chaining still possible</li>
</ul>

<p>Cons:</p>

<ul>
<li>Nested subselects</li>
<li>Very difficult to read in application code</li>
<li>The use of <code>DISTINCT ON</code> - only some RDBMS&#39; have such functionality</li>
</ul>

<h2>Approach 3: Window functions</h2>

<p>But there is still another option. The SQL standard defines a concept
called window functions, which act a lot like aggregates, but don&rsquo;t
change the result set. From the Postgresql documentation&rsquo;s <a title="Introduction to using window functions" href="http://www.postgresql.org/docs/9.1/static/tutorial-window.html">excellent
introduction to window functions</a>:</p>

<blockquote>
<p>A window function performs a calculation across a set of table rows that
are somehow related to the current row. This is comparable to the type
of calculation that can be done with an aggregate function. But unlike
regular aggregate functions, use of a window function does not cause
rows to become grouped into a single output row - the rows retain their
separate identities.</p>
</blockquote>

<p>Let&rsquo;s see how this would work with our dataset. First of all, let&rsquo;s assume the following cat pictures:</p>
<pre class="highlight plaintext"># SELECT id, name, category_id, price FROM cat_pictures ORDER BY category_id, price;

 id |         name         | category_id | price 
----+----------------------+-------------+-------
  7 | Triple LOL           |           1 |  9.99
  5 | Hugs not Drugs       |           1 |  9.99
  2 | Puss in Boots        |           1 | 14.99
  3 | Cats Gone By         |           1 | 19.99
  6 | Cats in it for me    |           1 | 22.99
  4 | Turkleton's Folly    |           2 | 11.99
  1 | Meowna Lisa          |           2 | 19.99
  8 | Lady Caterly's Lover |           2 | 22.99
</pre>

<p>Given this data, our goal is to select &ldquo;Hugs not Drugs&rdquo; and &ldquo;Turkleton&rsquo;s
Folly&rdquo;, which are the cheapest pictures from their categories.</p>

<p>Whereas a normal aggregate function with <code>GROUP BY</code> would collapse the
results, a window function retains the original row. Let&rsquo;s consider how
this would affect the inner query from the subselect approach above:</p>
<pre class="highlight plaintext"># SELECT category_id, min(price) FROM cat_pictures GROUP BY category_id;

 category_id |  min  
-------------+-------
           1 |  9.99
           2 | 11.99

</pre>
<pre class="highlight plaintext"># SELECT category_id, min(price) OVER (PARTITION BY category_id) FROM cat_pictures;

 category_id |  min  
-------------+-------
           1 |  9.99
           1 |  9.99
           1 |  9.99
           1 |  9.99
           1 |  9.99
           2 | 11.99
           2 | 11.99
           2 | 11.99
</pre>

<p>Above, we&rsquo;ve replaced the <code>GROUP BY</code> clause with an <code>OVER</code> clause. We
have the original rows with an additional column for this aggregate
data. This is useful in its own right, but the real power of window
functions comes from this concept of window framing. The use of
<code>PARTITION BY</code> creates a frame for each group. In our case, we have
two frames, one for each <code>category_id</code>. Then, all aggregate and window
functions before the <code>OVER</code> clause operate against this frame. Each
window frame effectively has its own result set, according to the
defined partition.</p>

<p>When a window frame is ordered, using an <code>ORDER BY</code> clause, even more
options are possible. For example, consider the following:</p>
<pre class="highlight plaintext"># SELECT id, name, category_id, price, rank() OVER (PARTITION BY category_id ORDER BY price) FROM cat_pictures;

 id |         name         | category_id | price | rank 
----+----------------------+-------------+-------+------
  7 | Triple LOL           |           1 |  9.99 |    1
  5 | Hugs not Drugs       |           1 |  9.99 |    1
  2 | Puss in Boots        |           1 | 14.99 |    3
  3 | Cats Gone By         |           1 | 19.99 |    4
  6 | Cats in it for me    |           1 | 22.99 |    5
  4 | Turkleton's Folly    |           2 | 11.99 |    1
  1 | Meowna Lisa          |           2 | 19.99 |    2
  8 | Lady Caterly's Lover |           2 | 22.99 |    3
</pre>

<p>Look familiar? This is essentially the original , except we&rsquo;ve added a
new column: its price rank within a window partitioned by <code>category_id</code>.
It&rsquo;s a mouthful to describe, but we&rsquo;re very close to our original goal
of finding the cheapest cat picture per category. All we need to do now
is select rows that have a rank of 1.</p>

<p>Not so fast. Can you spot the issue with the above? The <code>rank()</code> window
function assigns the same rank to ties, but we need the first one
alphabetically in the case of &ldquo;ties&rdquo;. We can remedy that by using a
different window function, <code>row_number()</code>, which guarantees different
numbers.</p>
<pre class="highlight plaintext"># SELECT id, name, category_id, price, row_number() OVER (PARTITION BY category_id ORDER BY price, name) FROM cat_pictures;

 id |         name         | category_id | price | row_number 
----+----------------------+-------------+-------+------------
  5 | Hugs not Drugs       |           1 |  9.99 |          1
  7 | Triple LOL           |           1 |  9.99 |          2
  2 | Puss in Boots        |           1 | 14.99 |          3
  3 | Cats Gone By         |           1 | 19.99 |          4
  6 | Cats in it for me    |           1 | 22.99 |          5
  4 | Turkleton's Folly    |           2 | 11.99 |          1
  1 | Meowna Lisa          |           2 | 19.99 |          2
  8 | Lady Caterly's Lover |           2 | 22.99 |          3
</pre>

<p>Perfect! Looking at the rows with &ldquo;1&rdquo; as their &ldquo;row_number&rdquo;, we see
what we expect, &ldquo;Hugs not Drugs&rdquo; and &ldquo;Turkleton&rsquo;s Folly&rdquo;, which are the
cheapest pictures from their categories. We can use an <code>IN</code> clause for
filtering, similar to the previous approach:</p>
<pre class="highlight sql"><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">category_id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">price</span>
<span class="k">FROM</span> <span class="n">cat_pictures</span>
<span class="k">WHERE</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">IN</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">OVER</span> <span class="p">(</span><span class="n">PARTITION</span> <span class="k">BY</span> <span class="n">category_id</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">price</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
  <span class="k">FROM</span> <span class="n">cat_pictures</span>
<span class="p">);</span>
</pre>
<pre class="highlight plaintext"> id | category_id |         name         | price 
----+-------------+----------------------+-------
  5 |           1 | Hugs not Drugs       |  9.99
  4 |           2 | Turkleton's Folly    | 11.99

</pre>

<p>The where clause above filters records that both have an id that appears
in the subquery next to a rank of 1. Now that we have the SQL down,
let&rsquo;s convert our Ruby model to take advantage of this window function
technique:</p>
<pre class="highlight ruby"><span class="k">class</span> <span class="nc">CatPicture</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:category_id</span><span class="p">,</span> <span class="ss">:description</span><span class="p">,</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:price</span>
    <span class="n">belongs_to</span> <span class="ss">:category</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">cheapest_per_category</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"(</span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">.id, 1) IN (</span><span class="si">#{</span><span class="n">price_rank_sql</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">price_rank_sql</span>
    <span class="n">scoped</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"id, row_number() OVER (PARTITION BY category_id ORDER BY price ASC, name ASC)"</span><span class="p">).</span><span class="nf">to_sql</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre>

<p>Groovy. Just like before, we can use to the power of ActiveRelation
to build up our subselect, which then gets interpolated into the
<code>where</code> clause. I&rsquo;ve also prepended <code>id</code> in the <code>where</code> clause with
<code>table_name</code>, to avoid potential ambiguous column problems.</p>

<p>There is one potential issue with using window functions: limited vendor
support. While most of the big boys implement window functions (Oracle,
Postgresql, and SQLServer, to name a few), MySQL and SQLite users are
out of luck.</p>

<p>Pros:</p>

<ul>
<li>Very performant (consistently twice as fast as Approach 2 on my laptop)</li>
<li>Much less noise than SQL subselect stuff</li>
<li>Easy to understand, assuming a basic knowledge of SQL window functions</li>
</ul>

<p>Cons:</p>

<ul>
<li>Not portable (window functions are not available in MySQL or SQLite)</li>
</ul>

<h2>Conclusion</h2>

<p>While they may not be appropriate for every situation, window functions
are a great tool for your toolbelt. They excel at filtering down rows
based on aggregate data, or adding aggregate data to the rows you&rsquo;d
already like to select.</p>

<p>For more information about window functions, the Postgres documentation
is an excellent resource, both for its <a title="Introduction to using window functions" href="http://www.postgresql.org/docs/9.1/static/tutorial-window.html">introduction</a>,
and its <a title="List of PostgreSQL window functions" href="http://www.postgresql.org/docs/9.1/static/functions-window.html">list of window functions</a>.</p>

<h2>Example app</h2>

<p>While writing this post, I created a <a title="Window functions example application" href="https://github.com/jgdavey/windowing-example/">sample Rails app</a> to iterate
quickly. I used TDD to write the pure-ruby approach, and reused the
specs while I &ldquo;refactored&rdquo; the implementation to the subsequent
approaches. Of particular note is <a title="Git history of the CatPicture model" href="https://github.com/jgdavey/windowing-example/commits/master/app/models/cat_picture.rb">the history of the CatPicture
model</a>, which mirrors the code above.</p>

</div>
</div>
</div>
</div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(["_setAccount", "UA-330362-1"]);
  _gaq.push(["_trackPageview"]);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? '//ssl' : '//www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
