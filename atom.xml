<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Awkward and Proud</title>
  <subtitle>Joshua Davey's blog stuff</subtitle>
  <id>http://joshuadavey.com/</id>
  <link href="http://joshuadavey.com/"/>
  <link href="http://joshuadavey.com/atom.xml" rel="self"/>
  <updated>2014-06-12T19:00:00-05:00</updated>
  <author>
    <name>Joshua Davey</name>
  </author>
  <entry>
    <title>
      <![CDATA[Screencast: Clojure + vim basics]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2014/06/13/screencast-clojure-and-vim-basics/"/>
    <id>http://joshuadavey.com/2014/06/13/screencast-clojure-and-vim-basics/</id>
    <published>2014-06-12T19:00:00-05:00</published>
    <updated>2014-06-13T10:53:37-05:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p>In this screencast I cover how to do basic evaluation and get Clojure
documentation from within vim. I&rsquo;m also including the transcript below.</p>

<iframe src="//player.vimeo.com/video/98052766" width="100%" height="280" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<p>Vim is a powerful text editor. Clojure is a powerful programming
language. While its been possible to edit Clojure code in vim for years,
the toolchain has improved greatly over the past year. Today we&rsquo;re going
to see how we can integrate vim with our Clojure REPL environment.</p>

<h1>Life without integration</h1>

<p>In a shell session, let&rsquo;s fire up a Clojure REPL. I&rsquo;m going to use <code>lein
repl</code> to do this. In another shell session, let&rsquo;s start vim and edit a
clojure file.</p>

<p>As I edit my file, I can copy code from the editor, switch to the window
with the REPL in it, and paste that code in. This works, but it&rsquo;s an
awkward, slow process. REPLs are supposed to be all about fast feedback.
We can do better than copy and paste.</p>

<h1>Plugins</h1>

<p>Before we get started, we should get the some basic plugins for clojure
development. Using your preferred vim plugin manager, add these plugins:</p>
<pre><code class="highlight plaintext">guns/vim-clojure-static
tpope/fireplace.vim
</code></pre>

<h1>Setup</h1>

<p>After you&rsquo;ve installed the necessary Vim plugins, enter a project
directory. For example, if you have a leiningen project, cd into the
directory. In one shell session, fire up a REPL with <code>lein repl</code>. In
another shell session, cd that that folder once again, and then open
vim.</p>

<p>Fireplace is able to detect when you are in the same directory as an
active REPL, and will attempt to automatically connect for you. This
process is transparent, but should be obvious once we attempt to to send
a command to the connected REPL.</p>

<h1>Evaluation</h1>

<p>The most basic fireplace command is <code>:Eval</code>. <code>:Eval</code> takes an arbitrary
clojure expression, sends it off to the REPL, and prints the result
for you. For example, we could run <code>:Eval (+ 1 1)</code>, and we would, as
expected, see <code>2</code> printed out. This emulates typing at REPL prompt
directly, but there&rsquo;s much more we can do with our REPL-connected vim
session.</p>

<p>Let&rsquo;s stay with <code>:Eval</code> for a bit longer. <code>:Eval</code> without any arguments
will send eval and print the outermost form on the current line. For
example, let&rsquo;s look at a simple expression.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>When we have our cursor on this line and type <code>:Eval</code> with no arguments,
we&rsquo;ll see <code>(2 3 4)</code> printed back.</p>

<p><code>:Eval</code>, as with many vim commands, can also take a range. So,
<code>:1,3Eval</code> would evaluate all of lines 1 through 3. All of the normal
special ranges work here, such as <code>%</code> for the entire file, and <code>&#39;&lt;,&#39;&gt;</code>
for the current selection in visual mode.</p>

<p><code>:Eval</code> works well, but there&rsquo;s a quicker way to get feedback. <code>cp</code> is
the normal mode mapping for doing a simple eval and print. By default,
<code>cp</code> expects a motion. The form that I use most though is <code>cpp</code>, which
will eval and print the innermost form from the cursor&rsquo;s current
position.</p>

<p>To demonstrate what this means, let&rsquo;s look at that expression again.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>When our cursor is on the <code>m</code> of <code>map</code>, and we type <code>cpp</code>, we&rsquo;ll see
<code>(2 3 4)</code>, just as when we did the plain <code>:Eval</code>. But if we move our
cursor inside the vector and type <code>cpp</code> again, we&rsquo;ll see that inner form
evaluated.</p>

<p>Something unique to fireplace is its concept of a quasi-REPL. This is a
cousin of the <code>cp</code> mappings, but with an intermediate editing window. To
demonstrate this, let&rsquo;s consider the following example.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="p">)</span><span class="w">
     </span><span class="nb">reverse</span><span class="w">
     </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="nb">dec</span><span class="p">))</span><span class="w">

</span></code></pre>

<p>In this trivial example, we want to reverse a sequence and decrement
each number. There&rsquo;s a bug in here, but it&rsquo;s in the middle of the
thread-through macro. We could just edit the line directly and
eval/print using <code>cpp</code>, but there&rsquo;s another way to do one-off iterative
development like this.</p>

<p>Type <code>cqc</code> in normal mode. A commandline window will open. This is very
much like a normal vim buffer, with a few notable exceptions:</p>

<ol>
<li>It cannot be modified or saved</li>
<li>Pressing <code>Enter</code> in normal mode sends the current line to the REPL
for eval-ing.</li>
<li>As you run commands, they are added to this buffer.</li>
</ol>

<p>tpope calls this the &ldquo;quasi-repl&rdquo;, and indeed that is the mnemonic for
the mapping itself: <code>cq</code> is the &ldquo;Clojure Quasi-REPL&rdquo;.</p>

<p>While we&rsquo;re in this special window, let&rsquo;s type the following, and hit
enter:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>Immediately, we can see the issue. Converting each number to a string
prevents <code>dec</code> from working later on.</p>

<p>Having to type the whole line again isn&rsquo;t always convenient. For those
cases, there&rsquo;s <code>cqq</code>, which is like <code>cqc</code> except that it pre-populates
the command window with the innermost form under the cursor. We can
see this in action by putting our cursor near the beginning of the
thread-through macro, and typing <code>cqq</code>.</p>

<p>You can think of <code>cqq</code> as being very similar to <code>cpp</code>, but with a chance
to edit the line or lines before sending it off to the REPL.</p>

<h1>Documentation</h1>

<p>One of the great things about Clojure is that documentation is a
first-class citizen, and builtin functions have documentation attached
to them. With a standard REPL, we can use the <code>doc</code> function to get the
signature and documentation for a given function.</p>

<p>With fireplace, we get this with the <code>:Doc</code> command, and it works just
like <code>doc</code>. To see the documentation for <code>map</code>, for example, type <code>:Doc
map</code>. We immediately see the documentation for the map command printed.</p>

<p>There&rsquo;s an even shorter way to look up documentation for a function.
When your cursor is on a word, you can press <code>K</code>, that is <code>Shift</code> and
<code>K</code>. We can try this again with the <code>map</code> function by placing our cursor
on the function itself, and pressing <code>K</code>.</p>

<p>We can also use the <code>:Source</code> command to show the source for a function.
When we do this with <code>map</code>, we see the source code for <code>map</code> from
<code>clojure.core</code>.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Using Datomic as a Graph Database]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2014/04/10/using-datomic-as-a-graph-database/"/>
    <id>http://joshuadavey.com/2014/04/10/using-datomic-as-a-graph-database/</id>
    <published>2014-04-09T19:00:00-05:00</published>
    <updated>2014-04-30T12:18:24-05:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Using Datomic as a Graph Database" href="http://hashrocket.com/blog/posts/using-datomic-as-a-graph-database">here</a></em></p>

<p>Datomic is a database that changes the way that you think about databases. It
also happens to be effective at modeling graph data and was a great fit for
performing graph traversal in a recent project I built.</p>

<p>I started out building <a href="http://kevinbacon.us/">kevinbacon.us</a> using <a href="http://www.neo4j.org/">Neo4j</a>, a popular
open-source graph database. It worked very well for actors that were a few hops
away, but finding paths between actors with more than 5 hops proved problematic.
The cypher query language gave me little visibility into the graph algorithms
actually being executed. I wanted more.</p>

<p>Despite not being explicitly labeled as such, Datomic proved to be an effective
graph database. Its ability to arbitrarily traverse datoms, when paired with
the appropriate graph searching algorithm, solved my problem elegantly. This
technique ended up being fast as well.</p>

<p>Quick aside: this post assumes a cursory understanding of Datomic. I won&rsquo;t cover
the basics, but the <a href="http://docs.datomic.com/tutorial.html">official tutorial</a> will help you get started.</p>

<h2>6 Degrees Kevin == Cool; 6 Degrees Kelvin == Cold</h2>

<p>The problem domain should be fairly familiar: <a href="http://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon">the 6 degrees of Kevin
Bacon</a>. I wanted to create an app where you could pick an
actor and find out what their Bacon Number was. That is, given an actor,
I wanted to answer the question &ldquo;how many degrees of separation is there
between that actor and Kevin Bacon?&rdquo;</p>

<p>Using <a href="http://www.imdb.com/interfaces">information freely available from IMDb</a>, I developed the following
schema:</p>
<pre><code class="highlight clojure"><span class="p">[</span><span class="w">
 </span><span class="c1">;; movies
</span><span class="w"> </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:movie/title</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/identity</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A movie's title (upsertable)"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:movie/year</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/long</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A movie's release year"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="c1">;; actors
</span><span class="w"> </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:person/name</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/identity</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A person's name (upsertable)"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/ref</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/many</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"An actor's ref to a movie"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
 </span><span class="p">]</span><span class="w">

</span></code></pre>

<p>In a nutshell, movies have titles and years. Actors have names and movies.
The &ldquo;relationship&rdquo; of actors to movies is many-to-many, so I&rsquo;ve declared the
<code>:actor/movies</code> attribute as having a cardinality of many.</p>

<h2>Using datalog queries</h2>

<p>Using datalog and <code>datomic.api/q</code>, we can make graph-like queries fairly easily.
Because the <code>:where</code> clauses of a datalog query form an implicit join, we can
join from our starting point to our ending point with relative ease.</p>

<p>As an example, what if we wanted to know the shortest path or paths from Kevin
Bacon to Jon Belushi? Let&rsquo;s use a query to find out:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">datomic.api</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">q</span><span class="w"> </span><span class="n">db</span><span class="p">]])</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">d/connect</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?title</span><span class="w"> </span><span class="n">?end</span><span class="w">
      </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
      </span><span class="no">:where</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?m</span><span class="w"> </span><span class="no">:movie/title</span><span class="w"> </span><span class="n">?title</span><span class="p">]]</span><span class="w">
    </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
    </span><span class="s">"Bacon, Kevin (I)"</span><span class="w">
    </span><span class="s">"Belushi, John"</span><span class="p">)</span><span class="w">

</span><span class="c1">;=&gt; #{["Bacon, Kevin (I)" "Animal House (1978)" "Belushi, John"]}
</span></code></pre>

<p>That is fine when actors have worked together in a movie (a Bacon Number of 1),
but doesn&rsquo;t help us solve Bacon numbers when there are 2 or more movies between
the actors. We could add more where clauses to join over two movies, but that
isn&rsquo;t sustainable. The queries would quickly become too long to reason about.
This is a prime opportunity to use Datomic&rsquo;s rules.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w">
  </span><span class="o">'</span><span class="p">[[(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">[</span><span class="n">?e1</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?e2</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[(</span><span class="nf">!=</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="p">)]</span><span class="w">
     </span><span class="p">[(</span><span class="nb">vector</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?m</span><span class="w"> </span><span class="n">?e2</span><span class="p">)</span><span class="w"> </span><span class="n">?path</span><span class="p">]]</span><span class="w">
    </span><span class="p">[(</span><span class="nf">acted-with-1</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
    </span><span class="p">[(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="n">?pp</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?p2</span><span class="p">)</span><span class="w">
     </span><span class="p">[(</span><span class="nb">butlast</span><span class="w"> </span><span class="n">?pp</span><span class="p">)</span><span class="w"> </span><span class="n">?p1</span><span class="p">]</span><span class="w">
     </span><span class="p">[(</span><span class="nb">concat</span><span class="w"> </span><span class="n">?p1</span><span class="w"> </span><span class="n">?p2</span><span class="p">)</span><span class="w"> </span><span class="n">?path</span><span class="p">]]])</span><span class="w">

</span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?path</span><span class="w">
     </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
     </span><span class="no">:where</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?a1</span><span class="w"> </span><span class="n">?a2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; #{[(17592186887476 17592186434418 17592187362817 17592186339273 17592186838882)] [(17592186887476 17592186434418 17592188400376 17592186529535 17592186838882)] [(17592186887476 17592186434418 17592187854963 17592186529535 17592186838882)] [(17592186887476 17592186434418 17592186926035 17592186302397 17592186838882)]}
</span></code></pre>

<p>This time we get back a collection of paths with entity ids. We can easily
transform these ids by mapping them into entities and getting the name or title,
using a function like the following:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">ent</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entity</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="no">:movie/title</span><span class="w"> </span><span class="n">ent</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:person/name</span><span class="w"> </span><span class="n">ent</span><span class="p">))))</span><span class="w">
</span></code></pre>

<p>So, putting the query together with the above function, we get:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
      </span><span class="nb">name</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="n">d</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?path</span><span class="w">
            </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
            </span><span class="no">:where</span><span class="w">
            </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?a1</span><span class="w"> </span><span class="n">?a2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
          </span><span class="n">d</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">mapv</span><span class="w"> </span><span class="nb">name</span><span class="p">))))</span><span class="w">
</span><span class="c1">;=&gt; (["Bieber, Justin" "Men in Black 3 (2012)" "Jones, Tommy Lee" "JFK (1991)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Howard, Rosemary (II)" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Segal, Tobias" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Brolin, Josh" "Hollow Man (2000)" "Bacon, Kevin (I)"])
</span></code></pre>

<p>The rules above are defined statically, but they are simply clojure data
structures: it would be trivial to generate those rules to an arbitrary
depth. For an example of doing just that, see the <a href="https://github.com/Datomic/mbrainz-sample/blob/master/src/clj/datomic/samples/mbrainz/rules.clj">Datomic mbrainz
sample</a>.</p>

<h2>Low-level traversal for better performance</h2>

<p>Having to know the depth at which to traverse the graph is cumbersome. Datomic
has a distinct advantage of being able to treat your data as local, even if its
permanent storage lives somewhere else. That means that we can bring our own
functions to the problem and execute locally, rather than on a database server.
We can leverage Datomic&rsquo;s <a href="http://docs.datomic.com/clojure/#datomic.api/datoms"><code>datoms</code> function</a> to search the graph using
our own graph-searching algorithm, rather than relying on the query engine.</p>

<p>Our IMDb actor data is essentially a dense unweighted graph. Because of its
density, a <a href="http://en.wikipedia.org/wiki/Bidirectional_search">bidirectional</a> <a href="http://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a> is probably the most
efficient alogrithm for finding the shortest paths from one point to another. A
generic bidirectional BFS returning all shortest paths might look like this.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">paths</span><span class="w">
  </span><span class="s">"Returns a lazy seq of all non-looping path vectors starting with
  [&lt;start-node&gt;]"</span><span class="w">
  </span><span class="p">[</span><span class="n">nodes-fn</span><span class="w"> </span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">this-node</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="nb">path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nodes-fn</span><span class="w"> </span><span class="n">this-node</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">not-any?</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="p">[</span><span class="n">this-node</span><span class="w"> </span><span class="n">%</span><span class="p">]))</span><span class="w">
                            </span><span class="p">(</span><span class="nf">partition</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">path</span><span class="p">)))</span><span class="w">
         </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">paths</span><span class="w"> </span><span class="n">nodes-fn</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="nb">path</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w">
         </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nb">path</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">trace-paths</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">start</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">m</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">paths</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">[</span><span class="n">start</span><span class="p">])))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">find-paths</span><span class="w"> </span><span class="p">[</span><span class="n">from-map</span><span class="w"> </span><span class="n">to-map</span><span class="w"> </span><span class="n">matches</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">matches</span><span class="w">
        </span><span class="n">from</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">reverse</span><span class="w"> </span><span class="p">(</span><span class="nf">trace-paths</span><span class="w"> </span><span class="n">from-map</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w">
        </span><span class="n">to</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="nf">trace-paths</span><span class="w"> </span><span class="n">to-map</span><span class="w"> </span><span class="n">n</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">to</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">neighbor-pairs</span><span class="w"> </span><span class="p">[</span><span class="n">neighbors</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="n">q</span><span class="w">
        </span><span class="n">nbr</span><span class="w"> </span><span class="p">(</span><span class="nf">neighbors</span><span class="w"> </span><span class="nb">node</span><span class="p">)</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">coll</span><span class="w"> </span><span class="n">nbr</span><span class="p">))]</span><span class="w">
    </span><span class="p">[</span><span class="n">nbr</span><span class="w"> </span><span class="nb">node</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bidirectional-bfs</span><span class="w"> </span><span class="p">[</span><span class="n">start</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">neighbors</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">find-pairs</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">neighbor-pairs</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w">
        </span><span class="n">overlaps</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">coll</span><span class="w"> </span><span class="n">q</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">coll</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">)))</span><span class="w">
        </span><span class="n">map-set-pairs</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="w"> </span><span class="n">pairs</span><span class="p">]</span><span class="w">
                        </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="w"> </span><span class="p">[</span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="p">]]</span><span class="w">
                                  </span><span class="p">(</span><span class="nf">assoc!</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="o">#</span><span class="p">{})</span><span class="w"> </span><span class="nb">val</span><span class="p">)))</span><span class="w">
                                </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="nb">map</span><span class="p">)</span><span class="w"> </span><span class="n">pairs</span><span class="p">)))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">preds</span><span class="w"> </span><span class="p">{</span><span class="n">start</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="c1">; map of outgoing nodes to where they came from
</span><span class="w">           </span><span class="n">succs</span><span class="w"> </span><span class="p">{</span><span class="n">end</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">   </span><span class="c1">; map of incoming nodes to where they came from
</span><span class="w">           </span><span class="n">q1</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w">   </span><span class="c1">; queue of outgoing things to check
</span><span class="w">           </span><span class="n">q2</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">end</span><span class="p">)]</span><span class="w">    </span><span class="c1">; queue of incoming things to check
</span><span class="w">      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">q1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">q2</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">q1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">q2</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">find-pairs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">preds</span><span class="p">)</span><span class="w">
                </span><span class="n">preds</span><span class="w"> </span><span class="p">(</span><span class="nf">map-set-pairs</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">pairs</span><span class="p">)</span><span class="w">
                </span><span class="n">q1</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">pairs</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="nf">overlaps</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="p">)]</span><span class="w">
              </span><span class="p">(</span><span class="nf">find-paths</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">all</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">q2</span><span class="p">)))</span><span class="w">
          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">find-pairs</span><span class="w"> </span><span class="n">q2</span><span class="w"> </span><span class="n">succs</span><span class="p">)</span><span class="w">
                </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nf">map-set-pairs</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">pairs</span><span class="p">)</span><span class="w">
                </span><span class="n">q2</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">pairs</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="nf">overlaps</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">q2</span><span class="p">)]</span><span class="w">
              </span><span class="p">(</span><span class="nf">find-paths</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">all</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">q2</span><span class="p">))))))))</span><span class="w">
</span></code></pre>

<p>There&rsquo;s a lot of code here, including some optimizations and helper functions.
The important function here is <code>bidirectional-bfs</code>. I won&rsquo;t explain the details
of the algorithm, but at a high level, it takes in a start and end node and a
function to be called on any node to get it&rsquo;s &ldquo;neighbors&rdquo;.</p>

<p>This is a generic, pure function, agnostic of Datomic or our data. In fact, I used
a simple map as the &ldquo;graph&rdquo; while developing this:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">graph</span><span class="w">
  </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="p">]</span><span class="w">
   </span><span class="no">:b</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="no">:d</span><span class="p">]</span><span class="w">
   </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="no">:e</span><span class="p">]</span><span class="w">
   </span><span class="no">:d</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="no">:e</span><span class="p">]</span><span class="w">
   </span><span class="no">:e</span><span class="w"> </span><span class="p">[</span><span class="no">:c</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="no">:f</span><span class="p">]</span><span class="w">
   </span><span class="no">:f</span><span class="w"> </span><span class="p">[]})</span><span class="w">

</span><span class="p">(</span><span class="nf">bidirectional-bfs</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="no">:e</span><span class="w"> </span><span class="n">graph</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; [[:a :b :c :e] [:a :b :d :e]]
</span></code></pre>

<p>To use this generic algorithm with our database, we need a <code>neighbors</code> function.
Depending on whether a node is an &ldquo;actor&rdquo; or a &ldquo;movie&rdquo;, we need to return its
appropriate counterpart. A naive &ldquo;or&rdquo; condition is actually good enough here:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">movie-actors</span><span class="w">
  </span><span class="s">"Given a Datomic database value and a movie id,
  returns ids for actors in that movie."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:e</span><span class="w"> </span><span class="p">(</span><span class="nf">d/datoms</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:vaet</span><span class="w"> </span><span class="n">eid</span><span class="w"> </span><span class="no">:actor/movies</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">actor-movies</span><span class="w">
  </span><span class="s">"Given a Datomic database value and an actor id,
  returns ids for movies that actor was in."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:v</span><span class="w"> </span><span class="p">(</span><span class="nf">d/datoms</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:eavt</span><span class="w"> </span><span class="n">eid</span><span class="w"> </span><span class="no">:actor/movies</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">neighbors</span><span class="w">
  </span><span class="s">"db is database value
  eid is an actor or movie eid"</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">actor-movies</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">movie-actors</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">))))</span><span class="w">

</span></code></pre>

<p>Gluing everything together is a simple matter of partial application:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">find-id-paths</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">target</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">bidirectional-bfs</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="n">db</span><span class="p">)))</span><span class="w">
</span></code></pre>

<p>Given a source entity id and a target entity id, this will return all shortest
paths (ids), much like the query example above. From there, we could map them
to Datomic entities, get their names, or sort the paths using a domain-specific
heuristic. Plugging in the previous example, we might do something like the
following:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
      </span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">d/filter</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">without-documentaries</span><span class="w"> </span><span class="n">d</span><span class="p">))</span><span class="w">
      </span><span class="n">biebs</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entid</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">[</span><span class="no">:actor/name</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="p">])</span><span class="w">
      </span><span class="n">bacon</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entid</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">[</span><span class="no">:actor/name</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">])</span><span class="w">
      </span><span class="nb">name</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="n">d</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">mapv</span><span class="w"> </span><span class="nb">name</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">find-id-paths</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">biebs</span><span class="w"> </span><span class="n">bacon</span><span class="p">)))</span><span class="w">
</span><span class="c1">;=&gt; (["Bieber, Justin" "Men in Black 3 (2012)" "Jones, Tommy Lee" "JFK (1991)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Segal, Tobias" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Brolin, Josh" "Hollow Man (2000)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Howard, Rosemary (II)" "R.I.P.D. (2013)" "Bacon, Kevin (I)"])
</span></code></pre>

<p>This returns the same set of paths as the query method did. However, this
version has the advantage of going to an arbitrary depth.</p>

<p>This is just one example of graph searching with Datomic. Different kinds of
problems and domains could use other algorithms. The idea, though, is that
generic graph searching functions can be used directly, since the data is
effectively local to the peer machine.</p>

<p>For more Clojure implementations of generic graph searching algorithms,
<a href="https://github.com/aysylu/loom">loom&rsquo;s</a> <a href="https://github.com/aysylu/loom/blob/master/src/loom/alg_generic.clj">alg_generic</a> namespace is a great starting point.</p>

<h2>Performance</h2>

<p>I&rsquo;m using the above ideas and functions on IMDB&rsquo;s dataset to power
<a href="http://kevinbacon.us/">kevinbacon.us</a>. Once the peer&rsquo;s index caches are warmed, the performance
is quite good: most searches I&rsquo;ve performed between well-known actors complete
in under a second, and in many cases, under 100 ms. I never got results that
good with Neo4j&rsquo;s cypher query language.</p>

<h2>Source</h2>

<p>The code in this post is based on the <a href="https://github.com/jgdavey/kevin">source</a> for <a href="http://kevinbacon.us/">kevinbacon.us</a>.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Deferring constraints in PostgreSQL]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2013/08/22/deferring-database-constraints/"/>
    <id>http://joshuadavey.com/2013/08/22/deferring-database-constraints/</id>
    <published>2013-08-21T19:00:00-05:00</published>
    <updated>2014-04-30T12:18:24-05:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Deferring constraints in PostgreSQL" href="http://hashrocket.com/blog/posts/deferring-database-constraints">here</a></em></p>

<p>Database constraints are essential to ensuring data integrity, and you
should use them. Allowing them to be deferrable during transactions
makes them even more convenient. A common scenario in which the database
can help us is in a sortable list implementation. This post outlines
the how and why of deferring database constraints, using a sortable list
domain as an example.</p>

<h1>Modeling lists of sortable items</h1>

<p>Imagine that you have an application with multiple lists. Each list has
items that can be reordered with a drag-and-drop interaction. This can
be modelled in a fairly straightforward manner.</p>

<p>Each list <code>has_many</code> list items, which are ordered by the <code>position</code>
column. Each list&rsquo;s items have a position beginning with 1 and
incrementing with each subsequent item.</p>
<pre><code class="highlight ruby"><span class="c1"># app/models/list.rb</span>
<span class="k">class</span> <span class="nc">List</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:items</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span> <span class="ss">:position</span> <span class="p">},</span> <span class="ss">class_name: </span><span class="s2">"ListItem"</span>
  <span class="n">validates_presence_of</span> <span class="ss">:name</span>
<span class="k">end</span>
</code></pre>
<pre><code class="highlight ruby"><span class="c1"># app/models/list_item.rb</span>
<span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:list</span>
  <span class="n">validates_presence_of</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:list</span><span class="p">,</span> <span class="ss">:position</span>

  <span class="n">before_validation</span> <span class="ss">:ensure_position</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
      <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">ensure_position</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">position</span> <span class="o">||=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">list_id: </span><span class="n">list_id</span><span class="p">).</span><span class="nf">maximum</span><span class="p">(</span><span class="ss">:position</span><span class="p">).</span><span class="nf">to_i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>A couple things are worth noting about the <code>ListItem</code> class. Firstly, we
have <code>update_positions</code>, a class method that accepts an array of ids and
updates each. This method will be called in a <code>sort</code> controller action
as such:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ItemsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">expose</span><span class="p">(</span><span class="ss">:list</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sort</span>
    <span class="c1"># list item ids is an ordered array of ids</span>
    <span class="n">list</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:list_item_ids</span><span class="o">]</span><span class="p">)</span>
    <span class="n">head</span> <span class="ss">:ok</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Secondly, new items don&rsquo;t necessarily know what position they should
have, so we put list items that don&rsquo;t have <code>position</code> at the end of
their respective list, just before validating that the position is
present.</p>

<p>Here are the migrations that we used to create the models&#39; database
tables:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateLists</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:lists</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:list_items</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:list</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:position</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>

      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Notice anything missing? If you said database constraints, you&rsquo;re
correct! Our application is enforcing presence for most attributes, but
our corresponding columns are missing <code>NOT NULL</code> constraints. Also, the
<code>list_id</code> column on <code>list_items</code> is missing a foreign key constraint.</p>

<p>But I&rsquo;d like to focus on another missing constraint. Our domain model has
an implicit requirement that we haven&rsquo;t enforced with either validations
or database constraints: each list item&rsquo;s position should be <em>unique per
list</em>. No two list items in a list should have the same position. That
would make the ordering non-deterministic.</p>

<p>We could add a uniqueness validation for <code>position</code>, scoped to
the <code>list_id</code>. However, as <a title="The Perils of Uniqueness Validations" href="http://robots.thoughtbot.com/post/55689359336/the-perils-of-uniqueness-validations">thoughtbot recently warned</a>,
application-level uniqueness validations are insufficient <em>at best</em>, and
fail completely in concurrent environments.</p>

<p>The <code>position</code> column needs a database-level constraint.</p>

<h1>Adding constraints</h1>

<p>Adding the uniqueness constraint to <code>position</code> is fairly straightforward
in PostgreSQL. We&rsquo;ll just create a new migration with the following:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">AddUniquenessValidationOnListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        add constraint list_item_position unique (list_id, position);
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        drop constraint if exists list_item_position;
</span><span class="no">    SQL</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Let&rsquo;s wrap our <code>UPDATE</code> statements in a transaction so that any failed
<code>UPDATE</code> of the position column will result in none of them being
updated:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This ensures at the database level that positions of items are unique
per list; no two items in the same list can occupy the &ldquo;1&rdquo; position.
With regard to data integrity, this is a huge improvement over our
initial implementation. But it has one drawback: <strong>it doesn&rsquo;t work</strong>.</p>

<p>To illustrate why, imagine a list with the following items:</p>
<pre><code class="highlight plaintext">id | position | name
13 | 1        | Eggs
18 | 2        | Milk
35 | 3        | Bread
</code></pre>

<p>To move Bread to the top of the list, we would pass an array of ids,
<code>[35,13,18]</code> to the <code>update_positions</code> method. This method does a series
of <code>UPDATE</code> statements to the database. For the first id, the one for
Bread, we end up sending an update statement that would look like the
following:</p>
<pre><code class="highlight sql"><span class="k">UPDATE</span> <span class="n">list_items</span> <span class="k">SET</span> <span class="k">position</span><span class="o">=</span><span class="mi">1</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">35</span><span class="p">;</span>
</code></pre>

<p>After this statement is executed in the database, but before we move on
to the next id in the list, Postgres will fail its constraint checks. At
the moment that the <code>UPDATE</code> happens, the data would be:</p>
<pre><code class="highlight plaintext">id | position | name
13 | 1        | Eggs
18 | 2        | Milk
35 | 1        | Bread
</code></pre>

<p>With both Eggs and Bread occupying the same position, the <code>UPDATE</code> fails.
Of course, we know that we want to change the position of Eggs as well,
so that its position would be &ldquo;2&rdquo;, and that collision would not happen.
But at the time that the constraint-check happens, the database doesn&rsquo;t
know this.</p>

<p>Even within a transaction, database uniqueness constraints are enforced
immediately <strong>per row</strong>. It seems our dreams of data integrity are
smashed. If only there were a way to enforce uniqueness constraints at
the end of the transaction, rather than the end of each statement&hellip;</p>

<h1>Deferrable Constraints</h1>

<p>As mentioned before, constraints are immediately enforced. This
behavior can be changed within a transaction by changing a constraints
deferrable characteristics. In PostgreSQL, constraints are assumed to
be <code>NOT DEFERRABLE</code> by default.</p>

<p>However, constraints can also behave as deferrable in one of two ways:
<code>DEFERRABLE INITIALLY IMMEDIATE</code> or <code>DEFERRABLE INITIALLY DEFERRED</code>.
The first part, <code>DEFERRABLE</code>, is what allows the database constraint
behavior to change within transactions. The second part describes what
the default behavior will be within a transaction.</p>

<p>With a constraint that is deferrable, but initially immediate, the
constraint will by default behave just like a non-deferrable constraint,
checking every statement immediately. A constraint that is initially
deferred will, by default, defer its checks until the transaction is
committed. Both of these can change their behavior per-transaction with a
call to <code>SET CONSTRAINTS</code> (<a href="http://www.postgresql.org/docs/9.2/static/sql-set-constraints.html">documentation</a>).</p>

<p>With that information, let&rsquo;s change the definition of the constraint we
defined before:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">AddUniquenessValidationOnListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        add constraint list_item_position unique (list_id, position)
        DEFERRABLE INITIALLY IMMEDIATE;
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        drop constraint if exists list_item_position;
</span><span class="no">    SQL</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>The only thing we&rsquo;ve changed from before is the <code>DEFERRABLE INITIALLY
IMMEDIATE</code> bit. I think it is a good idea to use the <code>INITIALLY
IMMEDIATE</code> option. This will ensure that other parts of our app, and
other consumers of the database will not be surprised by the behavior of
the constraint; it will continue to act a like a normal, non-deferrable
constraint, until we explicitly opt in to the deferral.</p>

<p>We now need to change our transaction block. In our case, the first
database statement within the transaction must be the <code>SET CONSTRAINTS</code>
statement:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">connection</span><span class="p">.</span><span class="nf">execute</span> <span class="s2">"SET CONSTRAINTS list_item_position DEFERRED"</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Having now opted in to deferring our uniqueness constraint, reordering
the items now works as expected. The constraint still ensures that we
don&rsquo;t have two items that occupy the same position, but waits until the
end of the transaction to do that check. We can have our data integrity
cake and eat it too.</p>

<h1>Bonus: deferrable introspection</h1>

<p>Having to name the constraint in two places is a bit of a bummer, and
introduces a coupling that could bite us if the constraint name ever
changed. Knowing that, we leverage PostgreSQL&rsquo;s introspective abilities
to query the constraint names instead.</p>

<p>For example, we can add the following module to our codebase:</p>
<pre><code class="highlight ruby"><span class="c1"># lib/deferrable.rb</span>
<span class="k">module</span> <span class="nn">Deferrable</span>
  <span class="k">def</span> <span class="nf">deferrable_uniqueness_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>
    <span class="n">usage</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'information_schema.constraint_column_usage'</span>
    <span class="n">constraint</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'pg_constraint'</span>
    <span class="n">arel</span> <span class="o">=</span> <span class="n">usage</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:constraint_name</span><span class="o">]</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">constraint</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:constraint_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:conname</span><span class="o">]</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">where</span><span class="p">(</span>
      <span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:contype</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="s1">'u'</span><span class="p">))</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:condeferrable</span><span class="o">]</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:table_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">table_name</span><span class="p">))</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:column_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">column_name</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">connection</span><span class="p">.</span><span class="nf">select_values</span> <span class="n">arel</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">transaction_with_deferred_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">constraints</span> <span class="o">=</span> <span class="n">deferrable_uniqueness_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">).</span><span class="nf">join</span> <span class="s2">","</span>
      <span class="n">connection</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="s2">"SET CONSTRAINTS %s DEFERRED"</span> <span class="o">%</span> <span class="n">constraints</span><span class="p">)</span>
      <span class="k">yield</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>And now change our model to use it:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">extend</span> <span class="no">Deferrable</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction_with_deferred_constraints_on</span><span class="p">(</span><span class="ss">:position</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>And, boom! Less coupling.</p>

<p><strong>NOTE</strong> That&rsquo;s a lot of Arel! Use at your own risk. ;-)</p>

<h1>Example application</h1>

<p>While writing this post, I created a <a href="https://github.com/jgdavey/uniqueness_constraints_example">sample Rails app</a> to iterate
quickly. I used TDD to write the initial approach, and reused the specs
while I &ldquo;refactored&rdquo; the implementation to the subsequent approaches.
Each <a href="https://github.com/jgdavey/uniqueness_constraints_example/commits/master">commit on the master branch</a> more or less follows the
sections above.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[has_one view]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2013/02/12/sql-views-and-activerecord/"/>
    <id>http://joshuadavey.com/2013/02/12/sql-views-and-activerecord/</id>
    <published>2013-02-11T18:00:00-06:00</published>
    <updated>2014-04-30T12:18:24-05:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="has_one view" href="http://hashrocket.com/blog/posts/sql-views-and-activerecord">here</a></em></p>

<p>Sometimes, aggregating data can become overly complex in a normal
ActiveRecord model. Because Rails works well with SQL views, we can
create associations to SQL views that aggregate data for us, simplifying
our models and potentially speeding up queries.</p>

<h2>Modeling an inbox</h2>

<p>I&rsquo;ve got an inbox. A cat inbox. For real.</p>

<p><img src="https://s3.amazonaws.com/hashrocket-blog-production/inbox.png" /></p>

<p>There are many possible implementations for modeling an inbox. I&rsquo;ve
gone with a relatively simple approach. Two users participate in a
conversation, sending messages back and forth to each other. The
Conversation model has a subject, but the body of the initial message is
part of the Message object.</p>
<pre><code class="highlight ruby"><span class="c1"># app/models/conversation.rb</span>
<span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># fields: to_id, from_id, subject</span>
  <span class="n">belongs_to</span> <span class="ss">:to</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">belongs_to</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">has_many</span> <span class="ss">:messages</span><span class="p">,</span> <span class="ss">dependent: :destroy</span><span class="p">,</span> <span class="ss">inverse_of: :conversation</span>
<span class="k">end</span>

<span class="c1"># app/models/message.rb</span>
<span class="k">class</span> <span class="nc">Message</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># fields: user_id, conversation_id, body</span>
  <span class="n">belongs_to</span> <span class="ss">:conversation</span><span class="p">,</span> <span class="ss">inverse_of: :messages</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
<span class="k">end</span>
</code></pre>

<p>After the initial message, the two participants on the conversation send
messages back and forth. A user may have any number of conversations
with other users. As such, the main inbox view must list the
conversations a user is a participant on, as well as some summary
information about that conversation.</p>

<p>For our purposes, we&rsquo;ve decided on an HTML table view with the following
columns:</p>

<ul>
<li>From - Who the original message was sent from</li>
<li>To - The original recipient of the message</li>
<li>Message - the Subject of the conversation, as well as the first line
of the most recent message</li>
<li>Last post - The date/time of the most recent message</li>
<li>Replies - The number of replies on the conversation (excluding the
first message)</li>
</ul>

<p>Although the subject is part of the conversation itself, everything else
comes from its various associations. This is the view, which reveals the
expected interface each conversation object should have:</p>
<pre><code class="highlight haml"><span class="nt">%table</span><span class="nf">#inbox</span>
  <span class="nt">%thead</span>
    <span class="nt">%tr</span>
      <span class="nt">%th</span> From
      <span class="nt">%th</span> To
      <span class="nt">%th</span> Message
      <span class="nt">%th</span> Last post
      <span class="nt">%th</span> Replies
  <span class="nt">%tbody</span>
    <span class="p">-</span> <span class="n">conversations</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">conversation</span><span class="o">|</span>
      <span class="nt">%tr</span>
        <span class="nt">%td</span><span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">from_name</span>
        <span class="nt">%td</span><span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">to_name</span>
        <span class="nt">%td</span>
          <span class="nt">%p</span>
            <span class="nt">%strong</span><span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">subject</span>
            <span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">most_recent_message_body</span>
        <span class="nt">%td</span>
          <span class="p">=</span> <span class="n">time_ago_in_words</span><span class="p">(</span><span class="n">conversation</span><span class="p">.</span><span class="nf">most_recent_message_sent_at</span><span class="p">)</span>
          ago
        <span class="nt">%td</span><span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">reply_count</span>
</code></pre>

<p>Let&rsquo;s explore a typical way to model this in our model directly.</p>

<h2>A typical Ruby implementation</h2>
<pre><code class="highlight ruby"><span class="c1"># app/models/conversation.rb</span>
<span class="k">class</span> <span class="nc">Converation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># associations, etc...</span>

  <span class="k">def</span> <span class="nf">most_recent_message_body</span>
    <span class="n">most_recent_message</span><span class="p">.</span><span class="nf">body</span> <span class="k">if</span> <span class="n">most_recent_message</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">most_recent_message_sent_at</span>
    <span class="n">most_recent_message</span><span class="p">.</span><span class="nf">created_at</span> <span class="k">if</span> <span class="n">most_recent_message</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">reply_count</span>
    <span class="n">messages</span><span class="p">.</span><span class="nf">size</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_name</span>
    <span class="n">to</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">from_name</span>
    <span class="n">from</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">most_recent_message</span>
    <span class="vi">@most_recent_message</span> <span class="o">||=</span> <span class="n">messages</span><span class="p">.</span><span class="nf">by_date</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># app/models/message.rb</span>
<span class="k">class</span> <span class="nc">Message</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># associations, etc...</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">by_date</span>
    <span class="n">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This approach is fairly straightforward. We obtain the
<code>most_recent_message_body</code> and <code>most_recent_message_sent_at</code> from the
most recent message, which is trivial after we&rsquo;ve ordered the <code>messages</code>
association by date. The <code>to_name</code> and <code>from_name</code> methods are delegated
to their respective associations. And <code>reply_count</code> is simple the total
number of messages, minus one (the initial message doesn&rsquo;t count as a
&ldquo;reply&rdquo;).</p>

<p>This approach offers a number of advantages. For one, it is familiar.
I believe most Rails developers would be able to understand exactly
what&rsquo;s going on above. It also locates all of the domain logic within
the <code>Conversation</code> model, making it easy to find.</p>

<p>Having everything in the <code>Conversation</code> model is actually a blessing
and a curse. Although everything is easy to find, the model is also
quickly becoming bloated. It may not seem like much right now, but as
more information is added to the inbox, it will become unruly.</p>

<p>The other problem with the above is the multitude of N+1 queries that
it has introduced. With only 3 conversations in play, loading the inbox
outputs a log like this:</p>
<pre><code class="highlight plaintext">Started GET "/" for 127.0.0.1 at 2013-02-11 09:49:02 -0600
Connecting to database specified by database.yml
Processing by InboxesController#show as HTML
  User Load (12.8ms)  SELECT "users".* FROM "users" LIMIT 1
  Conversation Load (0.6ms)  SELECT "conversations".* FROM "conversations" WHERE (1 IN (from_id, to_id))
  User Load (18.3ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 2 LIMIT 1
  User Load (0.5ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1
  Message Load (12.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 7 ORDER BY created_at DESC LIMIT 1
   (0.6ms)  SELECT COUNT(*) FROM "messages" WHERE "messages"."conversation_id" = 7
  User Load (0.4ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 3 LIMIT 1
  CACHE (0.0ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 8 ORDER BY created_at DESC LIMIT 1
   (0.4ms)  SELECT COUNT(*) FROM "messages" WHERE "messages"."conversation_id" = 8
  CACHE (0.0ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1
  CACHE (0.0ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 2 LIMIT 1
  Message Load (0.5ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 9 ORDER BY created_at DESC LIMIT 1
   (0.4ms)  SELECT COUNT(*) FROM "messages" WHERE "messages"."conversation_id" = 9
  Rendered inboxes/show.html.haml within layouts/application (683.9ms)
Completed 200 OK in 691ms (Views: 272.5ms | ActiveRecord: 418.1ms)
</code></pre>

<h2>Eager-loading</h2>

<p>We can definitely cut down on the N+1 query problem by introducing eager
loading. In our controller, the <code>conversations</code> exposure is currently
defined thusly:</p>
<pre><code class="highlight ruby"><span class="c1"># app/controllers/inboxes_controller.rb</span>
<span class="k">class</span> <span class="nc">InboxesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">expose</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
  <span class="n">expose</span><span class="p">(</span><span class="ss">:conversations</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">conversations</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>

<p>Let&rsquo;s change that to eagerly load its associations:</p>
<pre><code class="highlight ruby">  <span class="n">expose</span><span class="p">(</span><span class="ss">:conversations</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">conversations</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:messages</span><span class="p">,</span> <span class="ss">:to</span><span class="p">,</span> <span class="ss">:from</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>With eager-loading in place, the log now looks slightly more reasonable:</p>
<pre><code class="highlight plaintext">Started GET "/" for 127.0.0.1 at 2013-02-11 09:55:24 -0600
Processing by InboxesController#show as HTML
  User Load (0.3ms)  SELECT "users".* FROM "users" LIMIT 1
  Conversation Load (0.3ms)  SELECT "conversations".* FROM "conversations" WHERE (1 IN (from_id, to_id))
  Message Load (0.3ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" IN (7, 8, 9)
  User Load (0.2ms)  SELECT "users".* FROM "users" WHERE "users"."id" IN (1, 2)
  User Load (0.2ms)  SELECT "users".* FROM "users" WHERE "users"."id" IN (2, 3, 1)
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 7 ORDER BY created_at DESC LIMIT 1
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 8 ORDER BY created_at DESC LIMIT 1
  Message Load (0.3ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 9 ORDER BY created_at DESC LIMIT 1
  Rendered inboxes/show.html.haml within layouts/application (9.5ms)
Completed 200 OK in 13ms (Views: 10.0ms | ActiveRecord: 2.4ms)
</code></pre>

<p>There are more optimizations we could make here in Ruby land. But data
transformation and aggregation is something that databases are good at.
We can use a native feature of SQL to aggregate information for us:
views.</p>

<h2>SQL views</h2>

<p>A SQL view is essentially a virtual table. It can be queried just like a
normal table, but does not physically store anything itself. Instead, a
view has a query definition that it uses to represent its data.</p>

<p>In our case, SQL views can allow us to treat a complex SQL query as a
table, abstracting away the complexity into view itself. SQL views are
also read-only, and therefore are usually only used for querying, but
not updating data directly.</p>

<p>ActiveRecord plays nicely with SQL views out of the box. It considers a
SQL view a normal table, and all associations and querying methods work
like they would with a normal table, with one exception: the records are
read-only.</p>

<h2>Add a migration for the view</h2>

<p>Let&rsquo;s create a view to handle the <code>to_name</code> and <code>from_name</code> methods on
conversation. We can do this in a normal migration, but it needs to be
created with raw SQL:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateConversationSummaries</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      CREATE VIEW conversation_summaries AS
        SELECT ...
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="s1">'DROP VIEW conversation_summaries'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This is the basic syntax for adding a view with ActiveRecord migrations.
Our view needs to incorporate <code>to_name</code> and <code>from_name</code>, so let&rsquo;s add
those fields:</p>
<pre><code class="highlight sql"><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">conversation_summaries</span> <span class="k">AS</span>
  <span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
  <span class="n">f</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">from_name</span><span class="p">,</span>
  <span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">to_name</span>
  <span class="k">FROM</span> <span class="n">conversations</span> <span class="k">c</span>
  <span class="k">inner</span> <span class="k">join</span> <span class="n">users</span> <span class="n">t</span> <span class="k">on</span> <span class="n">t</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">to_id</span>
  <span class="k">inner</span> <span class="k">join</span> <span class="n">users</span> <span class="n">f</span> <span class="k">on</span> <span class="n">f</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">from_id</span>
</code></pre>

<p>After we migrate our database, we can use our database console to verify
that we see what we expect:</p>
<pre><code class="highlight plaintext">mailbox_development=# select * from conversation_summaries;
 id |    from_name    |     to_name
----+-----------------+-----------------
  7 | Felionel Richie | Cat Stevens
  8 | Nelly Purrtado  | Cat Stevens
  9 | Cat Stevens     | Felionel Richie
(3 rows)
</code></pre>

<p>Cool. The <code>id</code> corresponds to the conversation, and <code>to_name</code> and
<code>from_name</code> columns come from the users table, but it&rsquo;s all displayed to
us as one table.</p>

<h2>ActiveRecord associations for views</h2>

<p>Now that our view exists, we can integrate it into our application:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">class</span> <span class="nc">Summary</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">table_name</span> <span class="o">=</span> <span class="s2">"conversation_summaries"</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="s2">"id"</span>
    <span class="n">belongs_to</span> <span class="ss">:conversation</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"id"</span>
  <span class="k">end</span>

  <span class="n">has_one</span> <span class="ss">:summary</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"id"</span>
<span class="k">end</span>
</code></pre>

<p>Let&rsquo;s break down what&rsquo;s going on here.</p>

<p>I&rsquo;ve chosen to nest the Summary model within the Conversation
namespace, mostly to call out the fact that we&rsquo;re doing something
non-standard. Also, the Summary class only makes sense in the context of
a Conversation. For that reason, we need to manually set the name of the
table.</p>

<p>We must also choose a primary key, because Rails cannot infer it for SQL
views. The association itself should be familiar. It works like a normal
<code>has_one</code>/<code>belongs_to</code> relationship, except that we override the foreign
key.</p>

<p>Now that the relationships are set up, let&rsquo;s actually take advantage
of our new view by changing the implementation of the <code>to_name</code> and
<code>from_name</code> methods.</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nf">to_name</span>
    <span class="c1"># Used to be to.name</span>
    <span class="n">summary</span><span class="p">.</span><span class="nf">to_name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">from_name</span>
    <span class="c1"># Used to be from.name</span>
    <span class="n">summary</span><span class="p">.</span><span class="nf">from_name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>One the biggest benefits about this approach is that we can <em>eager-load
a view assocation</em>. We no longer need the <code>to</code> or <code>from</code> associations
eager-loaded, since we are no longer using any attributes from them in
the view. Let&rsquo;s update our controller&rsquo;s exposure to only eager-load the
necessary parts:</p>
<pre><code class="highlight ruby"><span class="n">expose</span><span class="p">(</span><span class="ss">:conversations</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">conversations</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:summary</span><span class="p">,</span> <span class="ss">:messages</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>And when we visit the inbox again, the log looks like this:</p>
<pre><code class="highlight plaintext">Started GET "/" for 127.0.0.1 at 2013-02-11 14:26:12 -0600
Processing by InboxesController#show as HTML
  User Load (0.5ms)  SELECT "users".* FROM "users" LIMIT 1
  Conversation Load (0.4ms)  SELECT "conversations".* FROM "conversations" WHERE (1 IN (from_id, to_id))
  Conversation::Summary Load (0.6ms)  SELECT "conversation_summaries".* FROM "conversation_summaries" WHERE "conversation_summaries"."id" IN (7, 8, 9)
  Message Load (0.3ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" IN (7, 8, 9)
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 7 ORDER BY created_at DESC LIMIT 1
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 8 ORDER BY created_at DESC LIMIT 1
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 9 ORDER BY created_at DESC LIMIT 1
  Rendered inboxes/show.html.haml within layouts/application (10.4ms)
Completed 200 OK in 13ms (Views: 9.5ms | ActiveRecord: 2.9ms)
</code></pre>

<p>That&rsquo;s definitely an improvement, albeit a small one. We&rsquo;ve pushed data
from the user model into our SQL view, but we don&rsquo;t need to stop there.</p>

<h2>Push it down!</h2>

<p>Let&rsquo;s update our view migration to include more aggregated information
about each conversation.</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateConversationSummaries</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      CREATE VIEW conversation_summaries AS
        SELECT c.id,
        f.name as from_name,
        t.name as to_name,
        m.body as most_recent_message_body,
        m.created_at as most_recent_message_sent_at,
        (select count(*) from messages m2 where m2.conversation_id = c.id) - 1 as reply_count
        FROM conversations c
        inner join users t on t.id = c.to_id
        inner join users f on f.id = c.from_id
        left outer join (
          select distinct on(conversation_id) conversation_id, body, created_at
          from messages m1
          order by conversation_id, created_at desc
        ) m ON m.conversation_id = c.id
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="s1">'DROP VIEW conversation_summaries'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>After running <code>rake db:migrate:redo</code>, we can verify that everything is
still working as expect in the database console:</p>
<pre><code class="highlight plaintext">mailbox_development=# select * from conversation_summaries;
 id |    from_name    |     to_name     |        most_recent_message_body        | most_recent_message_sent_at | reply_count 
----+-----------------+-----------------+----------------------------------------+-----------------------------+-------------
  7 | Felionel Richie | Cat Stevens     | Say you. Say meow.                     | 2013-02-08 02:45:27.07712   |           2
  8 | Nelly Purrtado  | Cat Stevens     | Except that I'm a cat                  | 2013-02-05 16:45:27.088292  |           0
  9 | Cat Stevens     | Felionel Richie | I'm sorry that you're feeling that way | 2013-01-30 16:45:27.092443  |           1
(3 rows)
</code></pre>

<p>That&rsquo;s a lot of SQL! But actually, all I&rsquo;ve added are one join to a
subquery, and a subselect. Let&rsquo;s review both of these changes.</p>

<p>There are many ways to grab the most recent message for a conversation
in SQL, including using <a href="http://blog.hashrocket.com/posts/sql-window-functions">window functions</a>. The method I&rsquo;ve opted for
here is a <a title="Postgresql documentation" href="http://www.postgresql.org/docs/9.2/static/queries-table-expressions.html#QUERIES-SUBQUERIES">subquery in the table expression</a>. The subquery
alone would return rows for only the most recent messages for each
conversation:</p>
<pre><code class="highlight plaintext">conversation_id |                  body                  |         created_at
----------------+----------------------------------------+----------------------------
              7 | Say you. Say meow.                     | 2013-02-08 02:45:27.07712
              8 | Except that I'm a cat                  | 2013-02-05 16:45:27.088292
              9 | I'm sorry that you're feeling that way | 2013-01-30 16:45:27.092443
</code></pre>

<p>By joining with only the most recent message per conversation, we avoid
duplicate rows and only get the <code>body</code> and <code>created_at</code> columns from
the most recent message. Then, joining against this subquery, we can
add the <code>body</code> and <code>created_at</code> to the list of projections, naming
them <code>most_recent_message_body</code> and <code>most_recent_message_sent_at</code>,
respectively.</p>

<p>The other thing we&rsquo;ve added to the view this iteration is the
<code>reply_count</code> column, which is a subselect to get the count. We also
subtract 1, just as before.</p>

<p>Let&rsquo;s take a look at our Conversation model now:</p>
<pre><code class="highlight ruby"><span class="c1"># before</span>
<span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:to</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">belongs_to</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">has_many</span> <span class="ss">:messages</span><span class="p">,</span> <span class="ss">dependent: :destroy</span><span class="p">,</span> <span class="ss">inverse_of: :conversation</span>

  <span class="k">def</span> <span class="nf">most_recent_message_body</span>
    <span class="n">most_recent_message</span><span class="p">.</span><span class="nf">body</span> <span class="k">if</span> <span class="n">most_recent_message</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">most_recent_message_sent_at</span>
    <span class="n">most_recent_message</span><span class="p">.</span><span class="nf">created_at</span> <span class="k">if</span> <span class="n">most_recent_message</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">reply_count</span>
    <span class="o">[</span><span class="n">messages</span><span class="p">.</span><span class="nf">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]</span><span class="p">.</span><span class="nf">max</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_name</span>
    <span class="n">to</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">from_name</span>
    <span class="n">from</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">most_recent_message</span>
    <span class="vi">@most_recent_message</span> <span class="o">||=</span> <span class="n">messages</span><span class="p">.</span><span class="nf">by_date</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>
<span class="k">end</span>


<span class="c1"># after</span>
<span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">class</span> <span class="nc">Summary</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">table_name</span> <span class="o">=</span> <span class="s2">"conversation_summaries"</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="s2">"id"</span>
    <span class="n">belongs_to</span> <span class="ss">:conversation</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"id"</span>
  <span class="k">end</span>

  <span class="n">belongs_to</span> <span class="ss">:to</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">belongs_to</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">has_many</span> <span class="ss">:messages</span><span class="p">,</span> <span class="ss">dependent: :destroy</span><span class="p">,</span> <span class="ss">inverse_of: :conversation</span>
  <span class="n">has_one</span> <span class="ss">:summary</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"id"</span>

  <span class="n">delegate</span> <span class="ss">:most_recent_message_sent_at</span><span class="p">,</span> <span class="ss">:most_recent_message_body</span><span class="p">,</span>
    <span class="ss">:reply_count</span><span class="p">,</span> <span class="ss">:to_name</span><span class="p">,</span> <span class="ss">:from_name</span><span class="p">,</span> <span class="ss">to: :summary</span>

<span class="k">end</span>
</code></pre>

<p>With much of our data transformation and aggregation in our SQL view,
our model has become trivially simple. It literally only contains
assocations and delegation now. We update our exposure to only
eager-load the conversation summary:</p>
<pre><code class="highlight ruby"><span class="n">expose</span><span class="p">(</span><span class="ss">:conversations</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">conversations</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:summary</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>Now, reloading the page yields the following log output:</p>
<pre><code class="highlight plaintext">Started GET "/" for 127.0.0.1 at 2013-02-11 15:37:49 -0600
Processing by InboxesController#show as HTML
  User Load (1.0ms)  SELECT "users".* FROM "users" LIMIT 1
  Conversation Load (0.2ms)  SELECT "conversations".* FROM "conversations" WHERE (1 IN (from_id, to_id))
  Conversation::Summary Load (0.8ms)  SELECT "conversation_summaries".* FROM "conversation_summaries" WHERE "conversation_summaries"."id" IN (7, 8, 9)
  Rendered inboxes/show.html.haml within layouts/application (5.5ms)
Completed 200 OK in 8ms (Views: 6.0ms | ActiveRecord: 2.0ms)
</code></pre>

<p>Now we see some real improvement. All N+1 queries are gone, replaced
instead with the eager-loading of the the Conversation::Summary model.</p>

<h2>Real World Benefits</h2>

<p>I used this technique in a real-world application. It helped abstract
some of the mundane details of the inbox and allowed us to think about
each conversation at a higher level with a summary.</p>

<p>In fact the app included even more business rules than I&rsquo;ve included
here. Each conversation had to include a read/unread status that updated
with each sent message. Although it was easily implemented in pure Ruby,
it cluttered the model and created yet more N+1 queries in the app view.</p>

<p>The inbox also had to be sorted by the most recent message date,
so that the conversation with the most recent activity would
appear first in the list. This kind of sorting without SQL is both
cumbersome and inefficient in Ruby; you have to load all messages
for each conversation. With the SQL view, it was as simple as
changing the scope from <code>user.conversations.include(:summary)</code> to
<code>user.conversations.include(:summary).order(&quot;conversation_summaries.most
_recent_message_sent_at DESC&quot;)</code>.</p>

<h2>Conclusion</h2>

<p>Any time that we push stuff into the database, we make a tradeoff.
In this case, when we move data transformation into the SQL view, we
sacrifice the co-location of the conversation model and the definition
of its summary. With the summary definition located in the database,
there&rsquo;s one extra layer of indirection.</p>

<p>The other tradeoff is that any time we&rsquo;d like to make a non-trivial
change the view, we actually have to create an entirely new view,
replacing the old one. If for example, we knew that our inbox was likely
to change or add fields, the SQL view approach might be too brittle.</p>

<p>On the other hand, we effectively removed N+1 queries from our
application and simplified our model considerably. By abstracting the
conversation&rsquo;s summary into a model backed by a SQL view, we&rsquo;re able
to think of the Summary as an object in its own right. This provides
a cognitive simplification, but also yields performance gains as the
dataset grows.</p>

<p>It may not be right for every situation, but knowing and understanding
how we can use SQL views in our Rails applications adds another tool to
our toolbelt.</p>

<h2>Example app</h2>

<p>As before, while writing this post, I created a <a href="https://github.com/jgdavey/sql_views">sample Rails app</a> to
iterate quickly. I used TDD to write the pure-ruby approach, and reused
the specs while I &ldquo;refactored&rdquo; the implementation to the subsequent
approaches. Of particular note is the <a href="https://github.com/jgdavey/tree-sql-example/commits/master/app/mo
dels/category.rb">history of the Conversation
model</a>, which mirrors the code above.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Using Recursive SQL with ActiveRecord trees]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2012/09/04/recursive-sql-in-activerecord/"/>
    <id>http://joshuadavey.com/2012/09/04/recursive-sql-in-activerecord/</id>
    <published>2012-09-03T19:00:00-05:00</published>
    <updated>2014-04-30T12:18:24-05:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Using Recursive SQL with ActiveRecord trees" href="http://hashrocket.com/blog/posts/recursive-sql-in-activerecord">here</a></em></p>

<p><strong>tl;dr</strong> When you have an ActiveRecord tree structure, using the WITH syntax for recursive SQL can provide large performance boons, especially when a tree get several levels deep.</p>

<p>In a <a title="SQL Window Functions and You" href="http://blog.hashrocket.com/posts/sql-window-functions">previous post</a>, I outlined a Cat Picture store application. As our store grows, more and more categories have to be created, and we end up with a tree of categories.
How can we create a homepage that includes all cat pictures for a given category <em>and</em> all of its subcategories?</p>

<p>Pictorally, the category tree might look like this:</p>
<pre><code class="highlight plaintext">Cat Pictures
|-- Funny
|   |-- LOLCats
|   `-- Animated
`-- Classic
    `-- Renaissance
</code></pre>

<p>On the landing page for the <em>Cat Pictures</em> category, we want to display
all cat pictures for any category below <em>Cat Pictures</em>. Navigating to
the <em>Funny</em> category would display all of its pictures, as well as the
pictures for <em>LOLCats</em> and <em>Animated</em>. This is the kind of interaction
seen on Amazon, for example. The store&rsquo;s categories become like an
ad-hoc filtering system.</p>

<p>Here&rsquo;s what the Category class looks like:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Category</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">attr_accessible</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:parent</span>

  <span class="n">has_many</span> <span class="ss">:cat_pictures</span>
  <span class="n">belongs_to</span> <span class="ss">:parent</span><span class="p">,</span> <span class="ss">:class_name</span> <span class="o">=&gt;</span> <span class="s2">"Category"</span>
  <span class="n">has_many</span> <span class="ss">:children</span><span class="p">,</span> <span class="ss">:class_name</span> <span class="o">=&gt;</span> <span class="s2">"Category"</span><span class="p">,</span> <span class="ss">:foreign_key</span> <span class="o">=&gt;</span> <span class="s1">'parent_id'</span>

  <span class="n">scope</span> <span class="ss">:top_level</span><span class="p">,</span> <span class="n">where</span><span class="p">(</span><span class="ss">:parent_id</span> <span class="o">=&gt;</span> <span class="kp">nil</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">descendents</span>
    <span class="c1"># implement me!</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Each category has a <code>parent_id</code> column that points at its parent
category. In database speak, modeling a tree like this is known as
an <em>Adjacency List</em>; each node of the tree can only see a children
immediately adjacent to it. For this reason, crawling an Adjacency List
requires recursion. This is actually the database setup common for use
with the <code>acts_as_tree</code> plugin. Let&rsquo;s see how we can implement the
<code>descendents</code> method to get all descendent categories.</p>

<h2>A Simple Ruby Approach</h2>

<p>As you&rsquo;ve probably already guessed, we need to recursively collect
children for each of our category&rsquo;s children.</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Category</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nf">descendents</span>
    <span class="n">children</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span>
      <span class="o">[</span><span class="n">child</span><span class="o">]</span> <span class="o">+</span> <span class="n">child</span><span class="p">.</span><span class="nf">descendents</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">flatten</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This does the job quite nicely. However, our requirements above state
that we want all cat pictures for each descendent category, <em>and our
categories</em>. Right now, we&rsquo;ve omitted the root category, self. Let&rsquo;s add
a new method to include it into the equation:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Category</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nf">descendents</span>
    <span class="n">children</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">child</span><span class="o">|</span>
      <span class="o">[</span><span class="n">child</span><span class="o">]</span> <span class="o">+</span> <span class="n">child</span><span class="p">.</span><span class="nf">descendents</span>
    <span class="k">end</span><span class="p">.</span><span class="nf">flatten</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">self_and_descendents</span>
    <span class="o">[</span><span class="nb">self</span><span class="o">]</span> <span class="o">+</span> <span class="n">descendents</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Good deal. Now gathering all cat pictures is just a matter of collecting
them for each category:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Category</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">descendent_pictures</span>
    <span class="n">self_and_descendents</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:cat_pictures</span><span class="p">).</span><span class="nf">flatten</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>For a tree like we have above, this is probably good enough. Our tree is
only 3 levels deep. We&rsquo;ve introduced plenty of N+1 queries, but given
our small dataset, that shouldn&rsquo;t be a huge concern.</p>

<p>That said, as our store grows, and the tree gets deeper and more
detailed, this kind of implementation could become a bottleneck. Also,
because we&rsquo;re doing Array operations on the <code>children</code> collection,
we lose the ability to take advantage of ActiveRelation outside of the
<code>descendents</code> method itself. Among other things, this means that we
can&rsquo;t eager-load cat pictures unless we always eager-load them within
the <code>descendents</code> method.</p>

<p>Surely we can do better.</p>

<h2>SQL WITH queries</h2>

<p>Since we&rsquo;re using PostgreSQL, we can take advantage of its special
features. In this case, we can use a WITH query. From the <a title="WITH queries" href="http://www.postgresql.org/docs/9.1/static/queries-with.html">PostgreSQL
documentation</a>:</p>

<blockquote>
<p>WITH provides a way to write auxiliary statements for use in a larger
query. These statements, which are often referred to as Common Table
Expressions or CTEs, can be thought of as defining temporary tables that
exist just for one query.</p>
</blockquote>

<p>On its own, this might not seem like a big deal, but when combined with
the optional RECURSIVE modifier, WITH queries can become quite powerful:</p>

<blockquote>
<p>The optional RECURSIVE modifier changes WITH from a mere syntactic
convenience into a feature that accomplishes things not otherwise
possible in standard SQL. Using RECURSIVE, a WITH query can refer to
its own output. A very simple example is this query to sum the integers
from 1 through 100:</p>
<pre><code class="highlight plaintext"> WITH RECURSIVE t(n) AS (
     VALUES (1)
   UNION ALL
     SELECT n+1 FROM t WHERE n &lt; 100
 )
 SELECT sum(n) FROM t;
</code></pre>

<p>The general form of a recursive WITH query is always a non-recursive
term, then UNION (or UNION ALL), then a recursive term, where only the
recursive term can contain a reference to the query&rsquo;s own output.</p>
</blockquote>

<p>In other words, the expression contained in the AS statement has two
parts. The first part is executed just once. The second part, after the
UNION ALL, is executed until it returns an empty result set.</p>

<p>Taking advantage of WITH RECURSIVE, we can reduce our tree crawling
technique from <em>n</em> queries to just 1! Let&rsquo;s how we can use this to crawl
our category tree.</p>

<p>As a reminder, here&rsquo;s what our categories table looks like:</p>
<pre><code class="highlight plaintext"># SELECT id, name, parent_id FROM categories;

 id |     name     | parent_id 
----+--------------+-----------
  1 | Cat Pictures |          
  2 | Funny        |         1
  3 | LOLCats      |         2
  4 | Animated     |         2
  5 | Classic      |         1
  6 | Renaissance  |         5
</code></pre>

<p>And this is the query:</p>
<pre><code class="highlight sql"><span class="k">WITH</span> <span class="k">RECURSIVE</span> <span class="n">category_tree</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="k">AS</span> <span class="p">(</span>
  <span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">id</span><span class="p">]</span>
  <span class="k">FROM</span> <span class="n">categories</span>
  <span class="k">WHERE</span> <span class="n">parent_id</span> <span class="k">IS</span> <span class="k">NULL</span>
<span class="k">UNION</span> <span class="k">ALL</span>
  <span class="k">SELECT</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">categories</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span> <span class="o">||</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span>
  <span class="k">FROM</span> <span class="n">category_tree</span>
  <span class="k">JOIN</span> <span class="n">categories</span> <span class="k">ON</span> <span class="n">categories</span><span class="p">.</span><span class="n">parent_id</span><span class="o">=</span><span class="n">category_tree</span><span class="p">.</span><span class="n">id</span>
  <span class="k">WHERE</span> <span class="k">NOT</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="k">ANY</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="p">)</span>
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">category_tree</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">path</span><span class="p">;</span>
</code></pre>

<p>Running the query above returns the following:</p>
<pre><code class="highlight plaintext"> id |     name     |  path   
----+--------------+---------
  1 | Cat Pictures | {1}
  2 | Funny        | {1,2}
  3 | LOLCats      | {1,2,3}
  4 | Animated     | {1,2,4}
  5 | Classic      | {1,5}
  6 | Renaissance  | {1,5,6}
</code></pre>

<p>Whoa! That&rsquo;s a lot of SQL. Let&rsquo;s break it down a bit. </p>

<h3>Declare the Table Expression</h3>

<p>First, we declare our &ldquo;temporary table&rdquo; using the WITH syntax. We&rsquo;re
going to call it <code>category_tree</code>. This &ldquo;table&rdquo; has 3 &ldquo;columns&rdquo;: <code>id</code>,
<code>name</code>, and <code>path</code>. The <code>id</code> and <code>name</code> columns are fairly obvious; they
refer to corresponding columns on the categories table. The <code>path</code> is an
array of ids that each row will have. More on this in a bit.</p>

<h3>Define the Non-recursive Term</h3>

<p>The non-recursive term is next:</p>
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ARRAY</span><span class="p">[</span><span class="n">id</span><span class="p">]</span>
<span class="k">FROM</span> <span class="n">categories</span>
<span class="k">WHERE</span> <span class="n">parent_id</span> <span class="k">IS</span> <span class="k">NULL</span>
</code></pre>

<p>It grabs the <code>id</code> and <code>name</code> for each top-level category, that is, each
category that has no parent. It also initializes an array containing just
its <code>id</code>. On its own, this isn&rsquo;t very interesting, but this array will
become helpful during the recursive step of the query.</p>

<h3>Define the Recursive Term</h3>

<p>The recursive term is the juiciest bit of the query:</p>
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">categories</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span> <span class="o">||</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span>
<span class="k">FROM</span> <span class="n">category_tree</span>
<span class="k">JOIN</span> <span class="n">categories</span> <span class="k">ON</span> <span class="n">categories</span><span class="p">.</span><span class="n">parent_id</span><span class="o">=</span><span class="n">category_tree</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="k">NOT</span> <span class="n">categories</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="k">ANY</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</code></pre>

<p>Notice that we&rsquo;re selecting from <code>category_tree</code>. By doing this, we&rsquo;re
able to use each result set in the subsequent iteration. The first time
we recurse, the result set will be what we selected in the non-recursive
term above.</p>

<p>Given that we have a root result set, we join with <code>categories</code> to find
its children. From our new result set, we select <code>id</code> and <code>name</code>, as
before. But this time, we concatenate the child id onto the <code>path</code> array
using SQL&rsquo;s <code>||</code> operator. Having this materialized path allows us to
guard against infinite loops; the WHERE clause makes sure that the row
we&rsquo;re selecting has not appeared in the path before.</p>

<p>This infinite loop check is important. If two categories pointed at each
other as parents, the query would never return. Including this check
prevents such a mistake from killing our server.</p>

<h3>Query the Common Table Expression</h3>

<p>Finally, a WITH query is only useful if you select from it outside of
its declaration, so we&rsquo;ll do just that:</p>
<pre><code class="highlight sql"><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">category_tree</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">path</span><span class="p">;</span>
</code></pre>

<p>In addition to the infinite loop guard, the path column answers the
question &ldquo;How did I get here?&rdquo; Like a directory structure on a file
system, the path demonstrates the ids necessary to get from grandparent
to parent to child, etc.</p>

<p>You may have noticed that we&rsquo;re also ordering by the path column.
We do this because the default sort from a recursive query is
nondeterministic. Normal array sorting works well for us here, and
groups the categories just like we&rsquo;d expect, with parents listed before
their children.</p>

<h2>Using WITH queries in ActiveRecord</h2>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Category</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nf">descendents</span>
    <span class="n">self_and_descendents</span> <span class="o">-</span> <span class="o">[</span><span class="nb">self</span><span class="o">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">self_and_descendents</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">tree_for</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">descendent_pictures</span>
    <span class="n">subtree</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">tree_sql_for</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
    <span class="no">CatPicture</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"category_id IN (</span><span class="si">#{</span><span class="n">subtree</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">tree_for</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="n">where</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">.id IN (</span><span class="si">#{</span><span class="n">tree_sql_for</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span><span class="si">}</span><span class="s2">)"</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"</span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="s2">.id"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">tree_sql_for</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="n">tree_sql</span> <span class="o">=</span>  <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      WITH RECURSIVE search_tree(id, path) AS (
          SELECT id, ARRAY[id]
          FROM </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="sh">
          WHERE id = </span><span class="si">#{</span><span class="n">instance</span><span class="p">.</span><span class="nf">id</span><span class="si">}</span><span class="sh">
        UNION ALL
          SELECT </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="sh">.id, path || </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="sh">.id
          FROM search_tree
          JOIN </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="sh"> ON </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="sh">.parent_id = search_tree.id
          WHERE NOT </span><span class="si">#{</span><span class="n">table_name</span><span class="si">}</span><span class="sh">.id = ANY(path)
      )
      SELECT id FROM search_tree ORDER BY path
</span><span class="no">    SQL</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>You should notice right away where our recursive query is. The
<code>tree_sql_for</code> class method returns a SQL string that can be used with
other queries. Compared to the WITH query we looked at before, there a
few differences worth mentioning.</p>

<p>First, and probably most importantly for our original problem, we&rsquo;ve
changed our starting place. The non-recursive term is our &ldquo;start here&rdquo;
result set. Rather than starting with all top-level categories, we&rsquo;re
using the id of whichever instance is passed in to scope our tree.</p>

<p>Another change we&rsquo;ve made is to remove the <code>name</code> column from the query.
It isn&rsquo;t necessary for what we&rsquo;re doing, but made the example easier to
demonstrate. We&rsquo;re also interpolating the table name. This makes the
method much more reusable. In fact, we could extract the method to a
<code>RecursiveTree</code> module to tidy up our class.</p>

<p>One big advantage of the SQL approach here is that we can create scopes
to further filter our results within just one database round-trip.
For example, the <code>tree_for</code> class method is really just a named scope
that takes a category instance as a parameter.</p>

<p>Likewise, the the <code>descendent_pictures</code> method returns a CatPicture
relation that includes all pictures from this category and all
subcategories. In other words, what used to take 2 database round trips
for each category in the tree (one to grab children, one to get its
pictures) will now only take 1 for the entire set.</p>

<h2>Conclusion</h2>

<p>Taking advantage of PostgreSQL&rsquo;s advanced features can provide large
performance boons, especially when a tree get several levels deep.</p>

<p>Although using database recursion is an efficient way of improving
performance with our existing schema, other methods of handling tree
structures in SQL exist. The <a title="SQL Antipatterns book" href="http://pragprog.com/book/bksqla/sql-antipatterns">SQL Antipatterns</a> book has a great
breakdown of other tree solutions that would require schema changes.</p>

<h2>Example app</h2>

<p>As before, while writing this post, I created a <a title="Example application with recursive tree SQL" href="https://github.com/jgdavey/tree-sql-example">sample Rails app</a> to
iterate quickly. I used TDD to write the pure-ruby approach, and reused
the specs while I &ldquo;refactored&rdquo; the implementation to the subsequent
approaches. Of particular note is the <a href="https://github.com/jgdavey/tree-sql-example/commits/master/app/mo
dels/category.rb">history of the Category
model</a>, which mirrors the code above.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Top 10 things GitHub will do with VC Funding]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2012/05/22/top-ten-things-github-will-do-with-vc-funding/"/>
    <id>http://joshuadavey.com/2012/05/22/top-ten-things-github-will-do-with-vc-funding/</id>
    <published>2012-05-21T19:00:00-05:00</published>
    <updated>2014-04-30T09:39:09-05:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p>GitHub is getting <a href="http://pandodaily.com/2012/05/21/bootstrapped-github-now-raising-a-round-from-andreessen-horowitz/">a round of VC funding</a>. Here are the top 10 things they plan on using the money for. </p>

<ol>
<li>Genetically engineer an actual octocat. </li>
<li>Pay off the anonymous Italian who&rsquo;s been squatting on &ldquo;code.it&rdquo;</li>
<li>Upgrade Rick Olsen to &ldquo;technosausage&rdquo;</li>
<li>Mojombo will finally buy back the username &ldquo;tom&rdquo; from the MySpace guy. </li>
<li>Build a room just for holding their giant piles of cash. </li>
<li>Get the lunar datacenter they&rsquo;ve been eying for months.</li>
<li>Develop a post-receive hook that actually kills a kitten when someone force pushes. </li>
<li>Buy Linus.</li>
<li>Fund the covert operation to eliminate the out-of-control self-aware Hubot. </li>
<li>Have a drinkup.</li>
</ol>
]]>
    </content>
  </entry>
</feed>
