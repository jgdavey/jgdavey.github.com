<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Awkward and Proud</title>
  <subtitle>Joshua Davey's blog stuff</subtitle>
  <id>http://joshuadavey.com/</id>
  <link href="http://joshuadavey.com/"/>
  <link href="http://joshuadavey.com/atom.xml" rel="self"/>
  <updated>2015-09-16T20:00:00-04:00</updated>
  <author>
    <name>Joshua Davey</name>
  </author>
  <entry>
    <title>
      <![CDATA[Bulk imports with Datomic]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2015/09/17/bulk-imports-with-datomic/"/>
    <id>http://joshuadavey.com/2015/09/17/bulk-imports-with-datomic/</id>
    <published>2015-09-16T20:00:00-04:00</published>
    <updated>2016-07-06T13:35:44-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Bulk imports with Datomic" href="https://hashrocket.com/blog/posts/bulk-imports-with-datomic">here</a></em></p>

<p>I&rsquo;ve been really happy with Datomic, but doing an initial bulk import
wasn&rsquo;t as familiar as SQL dump/restore. Here are some things that I&rsquo;ve
learned from doing several imports.</p>

<h2>Use core.async</h2>

<p>The Datomic transactor handles concurrency by transacting datoms
serially, but that doesn&rsquo;t mean it isn&rsquo;t fast! In my experience, the bottleneck is actually in the
reshaping of data and formatting transactions. I
use <code>core.async</code> to parallelize just about everything in the import
pipeline.</p>

<p>One example of how I&rsquo;ve leveraged <code>core.async</code> for
import jobs can be found in my <a href="https://github.com/jgdavey/kevin/blob/master/src/kevin/loader.clj">Kevin Bacon project
repository</a>.</p>

<h2>Run the import locally</h2>

<p>I use DynamoDB as my storage backend in production. I used to try to
run my import tasks directly to the production transactor/storage.
Lately, though, I&rsquo;ve found it really helpful to run my import tasks to
a locally-running transactor and the <code>dev</code> storage backend.</p>

<p>Running an import locally means I don&rsquo;t have to worry about networking, which speeds the whole process up quite a bit; also, it give me a much more freedom to iterate on the database
design itself. (I rarely get an import correct the first time.) And
in the case of DynamoDB, I save some money, as I don&rsquo;t have to have my
&ldquo;write throughput&rdquo; cranked way up for as long.</p>

<h2>Clean up the local database</h2>

<p>Bulk imports create some garbage, so manually reindexing before backing
up is advantageous. Here&rsquo;s what a REPL session looks like:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">d/connect</span><span class="w"> </span><span class="err">"</span><span class="n">datomic</span><span class="no">:dev://localhost:4334/database-name</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">d/request-index</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="n">d/db</span><span class="w"> </span><span class="n">d/basis-t</span><span class="w"> </span><span class="p">(</span><span class="nf">d/sync-index</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="nb">deref</span><span class="p">)</span><span class="w">
</span><span class="c1">;; blocks until done indexing
</span><span class="p">(</span><span class="nf">d/gc-storage</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.Date.</span><span class="p">))</span><span class="w">
</span></code></pre>

<p>For more information on why this cleanup
is important, see <a href="http://docs.datomic.com/capacity.html#sec-2-4">the relevant Datomic
documentation</a>.</p>

<h2>Use backup/restore</h2>

<p>Once everything looks good on the local production database, I use
Datomic&rsquo;s builtin backup/restore facilities to send the database
up to production. Assuming you&rsquo;ve already deployed a production transactor and provisioned DynamoDB storage, here&rsquo;s the process I follow:</p>

<ol>
<li>Run the <code>datomic backup-db</code> command against the local import.</li>
<li>Crank my &ldquo;write throughput&rdquo; on DynamoDB <em>way</em> up (on the order of 1000).</li>
<li>Run the <code>datomic restore-db</code> command from the backup folder to the
remote database.</li>
<li>Turn the &ldquo;write throughput&rdquo; back down to whatever
value I plan to use for ongoing use (see <a href="http://docs.datomic.com/capacity.html#sec-5">the Datomic
documentation</a> for more
information).</li>
</ol>

<p>The heart of almost every business is its data. Datomic is a great
choice for business data, in part because it treats <em>all</em> data as
important: nothing is overwritten. New things are learned, but the old
facts are not replaced. And knowing how to get your data into Datomic
is half the battle.</p>

<p>Go forth and import!</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Boot + Middleman: The ClojureScript development environment of my dreams]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2015/06/04/boot-middleman/"/>
    <id>http://joshuadavey.com/2015/06/04/boot-middleman/</id>
    <published>2015-06-03T20:00:00-04:00</published>
    <updated>2016-07-06T13:35:06-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Boot + Middleman: The ClojureScript development environment of my dreams" href="https://hashrocket.com/blog/posts/the-front-end-development-environment-of-my-dreams">here</a></em></p>

<p>I&rsquo;m getting closer to the frontend development environment of my dreams. The
combination of editor integration, live browser reload, and not having to
manually run commands over and over is time-saving and a pleasure to
work with.</p>

<p>At Hashrocket, designers and developers work very closely
together. Visual design and markup is handled by our
designers, who create &ldquo;stubbed out&rdquo; templates in <a href="http://hashrocket.com/blog/posts/managing-design-handoffs-with-the-ui-controller">the UI
directory</a>.
It&rsquo;s a process that works very well for us, and
allows us to iteratively add features to an application.</p>

<p>This process has served us very well in Rails using a <a href="http://hashrocket.com/blog/posts/managing-design-handoffs-with-the-ui-controller">UI
controller</a>,
available only in development mode.</p>

<p>I&rsquo;ve been using ClojureScript a lot lately, particularly with Om, and
have missed that directory of collaboration. After all, the designers
at Hashrocket have a proclivity for HAML and SASS.</p>

<p>In the past, I&rsquo;ve set up a separate repository using <a href="https://middlemanapp.com">Middleman</a> to
handle markup and styles, using <code>middleman build</code>, copying the generated
CSS files, and eyeballing the generated markup to ensure it matched the
Om component&rsquo;s markup. Aside from being tedious, it&rsquo;s really easy to
get out of sync with a manual process like this. The static resource
generation should be a part of our build process.</p>

<p>Enter <a href="http://boot-clj.com">boot</a>.</p>

<h3>Using Boot for ClojureScript development</h3>

<p>If you&rsquo;re new to the Clojure world, you may have heard of <a href="http://leiningen.org">Leiningen</a>,
which is the de facto dependency management and build tool for
Clojure/Script. Boot is similar to Leiningen, but adds the ability to
compose tasks to create build pipelines. This composability, along with
some really smart architectural decisions, is what makes boot a great
choice for the problem at hand.</p>

<p>Adzerk&rsquo;s <a href="https://github.com/adzerk-oss/boot-cljs-example">example repo</a>
is a great way to get started with ClojureScript and boot. Of particular
note is the <code>build.boot</code> file. It demonstrates how one can build
up a <code>dev</code> task that watches a directory for changes, rebuilding
ClojureScript sources, and notifying the browser to reload the code. It
includes the setup necessary for source maps, a development server,
and the browser-connected REPL. But what I want to add to that pot
of awesome is the ability to compile HAML and SASS as a part of the
pipeline.</p>

<h3>boot-middleman: Gluing Everything Together</h3>

<p>I had an epiphany one night after working on this problem for a while: I
can just use Middleman. After all, boot and the ClojureScript compiler
run on the JVM, and JRuby is easily embeddable. After a short bit, I
came up with <a href="https://github.com/jgdavey/boot-middleman">boot-middleman</a>, the glue I needed to build HAML/SASS as
a part of my build process.</p>

<p>It assumes a subdirectory is a Middleman app (<code>assets</code> by default). This
works nicely because my designer pals can collaborate with me without
having to use the JVM at all. They just run <code>middleman</code> in the <code>assets</code>
subdirectory and work as normal.</p>

<p>See the boot-middleman README for instructions on setting up.</p>

<p>I used this workflow to create a minesweeper clone, <a href="https://github.com/jgdavey/minesweeper">the
source</a> of which is on GitHub.
Just clone and run <code>boot dev</code>.</p>

<h3>The Workflow in Action</h3>

<p>To see the workflow in action, check out the following video. It
demonstrates how editing front-end files do not require a manual browser
refresh to see the effects.</p>

<iframe src="https://player.vimeo.com/video/128494099" width="500" height="280" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Screencast: Clojure + vim basics]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2014/06/13/screencast-clojure-and-vim-basics/"/>
    <id>http://joshuadavey.com/2014/06/13/screencast-clojure-and-vim-basics/</id>
    <published>2014-06-12T20:00:00-04:00</published>
    <updated>2016-07-06T13:36:19-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p>In this screencast I cover how to do basic evaluation and get Clojure
documentation from within vim. I&rsquo;m also including the transcript below.</p>

<iframe src="//player.vimeo.com/video/98052766" width="100%" height="280" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<p>Vim is a powerful text editor. Clojure is a powerful programming
language. While its been possible to edit Clojure code in vim for years,
the toolchain has improved greatly over the past year. Today we&rsquo;re going
to see how we can integrate vim with our Clojure REPL environment.</p>

<h1>Life without integration</h1>

<p>In a shell session, let&rsquo;s fire up a Clojure REPL. I&rsquo;m going to use <code>lein
repl</code> to do this. In another shell session, let&rsquo;s start vim and edit a
clojure file.</p>

<p>As I edit my file, I can copy code from the editor, switch to the window
with the REPL in it, and paste that code in. This works, but it&rsquo;s an
awkward, slow process. REPLs are supposed to be all about fast feedback.
We can do better than copy and paste.</p>

<h1>Plugins</h1>

<p>Before we get started, we should get the some basic plugins for clojure
development. Using your preferred vim plugin manager, add these plugins:</p>
<pre><code class="highlight plaintext">guns/vim-clojure-static
tpope/fireplace.vim
</code></pre>

<h1>Setup</h1>

<p>After you&rsquo;ve installed the necessary Vim plugins, enter a project
directory. For example, if you have a leiningen project, cd into the
directory. In one shell session, fire up a REPL with <code>lein repl</code>. In
another shell session, cd that that folder once again, and then open
vim.</p>

<p>Fireplace is able to detect when you are in the same directory as an
active REPL, and will attempt to automatically connect for you. This
process is transparent, but should be obvious once we attempt to to send
a command to the connected REPL.</p>

<h1>Evaluation</h1>

<p>The most basic fireplace command is <code>:Eval</code>. <code>:Eval</code> takes an arbitrary
clojure expression, sends it off to the REPL, and prints the result
for you. For example, we could run <code>:Eval (+ 1 1)</code>, and we would, as
expected, see <code>2</code> printed out. This emulates typing at REPL prompt
directly, but there&rsquo;s much more we can do with our REPL-connected vim
session.</p>

<p>Let&rsquo;s stay with <code>:Eval</code> for a bit longer. <code>:Eval</code> without any arguments
will send eval and print the outermost form on the current line. For
example, let&rsquo;s look at a simple expression.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>When we have our cursor on this line and type <code>:Eval</code> with no arguments,
we&rsquo;ll see <code>(2 3 4)</code> printed back.</p>

<p><code>:Eval</code>, as with many vim commands, can also take a range. So,
<code>:1,3Eval</code> would evaluate all of lines 1 through 3. All of the normal
special ranges work here, such as <code>%</code> for the entire file, and <code>&#39;&lt;,&#39;&gt;</code>
for the current selection in visual mode.</p>

<p><code>:Eval</code> works well, but there&rsquo;s a quicker way to get feedback. <code>cp</code> is
the normal mode mapping for doing a simple eval and print. By default,
<code>cp</code> expects a motion. The form that I use most though is <code>cpp</code>, which
will eval and print the innermost form from the cursor&rsquo;s current
position.</p>

<p>To demonstrate what this means, let&rsquo;s look at that expression again.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>When our cursor is on the <code>m</code> of <code>map</code>, and we type <code>cpp</code>, we&rsquo;ll see
<code>(2 3 4)</code>, just as when we did the plain <code>:Eval</code>. But if we move our
cursor inside the vector and type <code>cpp</code> again, we&rsquo;ll see that inner form
evaluated.</p>

<p>Something unique to fireplace is its concept of a quasi-REPL. This is a
cousin of the <code>cp</code> mappings, but with an intermediate editing window. To
demonstrate this, let&rsquo;s consider the following example.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="p">)</span><span class="w">
     </span><span class="nb">reverse</span><span class="w">
     </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="nb">dec</span><span class="p">))</span><span class="w">

</span></code></pre>

<p>In this trivial example, we want to reverse a sequence and decrement
each number. There&rsquo;s a bug in here, but it&rsquo;s in the middle of the
thread-through macro. We could just edit the line directly and
eval/print using <code>cpp</code>, but there&rsquo;s another way to do one-off iterative
development like this.</p>

<p>Type <code>cqc</code> in normal mode. A commandline window will open. This is very
much like a normal vim buffer, with a few notable exceptions:</p>

<ol>
<li>It cannot be modified or saved</li>
<li>Pressing <code>Enter</code> in normal mode sends the current line to the REPL
for eval-ing.</li>
<li>As you run commands, they are added to this buffer.</li>
</ol>

<p>tpope calls this the &ldquo;quasi-repl&rdquo;, and indeed that is the mnemonic for
the mapping itself: <code>cq</code> is the &ldquo;Clojure Quasi-REPL&rdquo;.</p>

<p>While we&rsquo;re in this special window, let&rsquo;s type the following, and hit
enter:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>Immediately, we can see the issue. Converting each number to a string
prevents <code>dec</code> from working later on.</p>

<p>Having to type the whole line again isn&rsquo;t always convenient. For those
cases, there&rsquo;s <code>cqq</code>, which is like <code>cqc</code> except that it pre-populates
the command window with the innermost form under the cursor. We can
see this in action by putting our cursor near the beginning of the
thread-through macro, and typing <code>cqq</code>.</p>

<p>You can think of <code>cqq</code> as being very similar to <code>cpp</code>, but with a chance
to edit the line or lines before sending it off to the REPL.</p>

<h1>Documentation</h1>

<p>One of the great things about Clojure is that documentation is a
first-class citizen, and builtin functions have documentation attached
to them. With a standard REPL, we can use the <code>doc</code> function to get the
signature and documentation for a given function.</p>

<p>With fireplace, we get this with the <code>:Doc</code> command, and it works just
like <code>doc</code>. To see the documentation for <code>map</code>, for example, type <code>:Doc
map</code>. We immediately see the documentation for the map command printed.</p>

<p>There&rsquo;s an even shorter way to look up documentation for a function.
When your cursor is on a word, you can press <code>K</code>, that is <code>Shift</code> and
<code>K</code>. We can try this again with the <code>map</code> function by placing our cursor
on the function itself, and pressing <code>K</code>.</p>

<p>We can also use the <code>:Source</code> command to show the source for a function.
When we do this with <code>map</code>, we see the source code for <code>map</code> from
<code>clojure.core</code>.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Using Datomic as a Graph Database]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2014/04/10/using-datomic-as-a-graph-database/"/>
    <id>http://joshuadavey.com/2014/04/10/using-datomic-as-a-graph-database/</id>
    <published>2014-04-09T20:00:00-04:00</published>
    <updated>2016-07-06T13:36:52-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Using Datomic as a Graph Database" href="http://hashrocket.com/blog/posts/using-datomic-as-a-graph-database">here</a></em></p>

<p>Datomic is a database that changes the way that you think about databases. It
also happens to be effective at modeling graph data and was a great fit for
performing graph traversal in a recent project I built.</p>

<p>I started out building <a href="http://kevinbacon.us/">kevinbacon.us</a> using <a href="http://www.neo4j.org/">Neo4j</a>, a popular
open-source graph database. It worked very well for actors that were a few hops
away, but finding paths between actors with more than 5 hops proved problematic.
The cypher query language gave me little visibility into the graph algorithms
actually being executed. I wanted more.</p>

<p>Despite not being explicitly labeled as such, Datomic proved to be an effective
graph database. Its ability to arbitrarily traverse datoms, when paired with
the appropriate graph searching algorithm, solved my problem elegantly. This
technique ended up being fast as well.</p>

<p>Quick aside: this post assumes a cursory understanding of Datomic. I won&rsquo;t cover
the basics, but the <a href="http://docs.datomic.com/tutorial.html">official tutorial</a> will help you get started.</p>

<h2>6 Degrees Kevin == Cool; 6 Degrees Kelvin == Cold</h2>

<p>The problem domain should be fairly familiar: <a href="http://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon">the 6 degrees of Kevin
Bacon</a>. I wanted to create an app where you could pick an
actor and find out what their Bacon Number was. That is, given an actor,
I wanted to answer the question &ldquo;how many degrees of separation is there
between that actor and Kevin Bacon?&rdquo;</p>

<p>Using <a href="http://www.imdb.com/interfaces">information freely available from IMDb</a>, I developed the following
schema:</p>
<pre><code class="highlight clojure"><span class="p">[</span><span class="w">
 </span><span class="c1">;; movies
</span><span class="w"> </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:movie/title</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/identity</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A movie's title (upsertable)"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:movie/year</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/long</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A movie's release year"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="c1">;; actors
</span><span class="w"> </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:person/name</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/identity</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A person's name (upsertable)"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/ref</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/many</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"An actor's ref to a movie"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
 </span><span class="p">]</span><span class="w">

</span></code></pre>

<p>In a nutshell, movies have titles and years. Actors have names and movies.
The &ldquo;relationship&rdquo; of actors to movies is many-to-many, so I&rsquo;ve declared the
<code>:actor/movies</code> attribute as having a cardinality of many.</p>

<h2>Using datalog queries</h2>

<p>Using datalog and <code>datomic.api/q</code>, we can make graph-like queries fairly easily.
Because the <code>:where</code> clauses of a datalog query form an implicit join, we can
join from our starting point to our ending point with relative ease.</p>

<p>As an example, what if we wanted to know the shortest path or paths from Kevin
Bacon to Jon Belushi? Let&rsquo;s use a query to find out:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">datomic.api</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">q</span><span class="w"> </span><span class="n">db</span><span class="p">]])</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">d/connect</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?title</span><span class="w"> </span><span class="n">?end</span><span class="w">
      </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
      </span><span class="no">:where</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?m</span><span class="w"> </span><span class="no">:movie/title</span><span class="w"> </span><span class="n">?title</span><span class="p">]]</span><span class="w">
    </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
    </span><span class="s">"Bacon, Kevin (I)"</span><span class="w">
    </span><span class="s">"Belushi, John"</span><span class="p">)</span><span class="w">

</span><span class="c1">;=&gt; #{["Bacon, Kevin (I)" "Animal House (1978)" "Belushi, John"]}
</span></code></pre>

<p>That is fine when actors have worked together in a movie (a Bacon Number of 1),
but doesn&rsquo;t help us solve Bacon numbers when there are 2 or more movies between
the actors. We could add more where clauses to join over two movies, but that
isn&rsquo;t sustainable. The queries would quickly become too long to reason about.
This is a prime opportunity to use Datomic&rsquo;s rules.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w">
  </span><span class="o">'</span><span class="p">[[(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">[</span><span class="n">?e1</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?e2</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[(</span><span class="nf">!=</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="p">)]</span><span class="w">
     </span><span class="p">[(</span><span class="nb">vector</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?m</span><span class="w"> </span><span class="n">?e2</span><span class="p">)</span><span class="w"> </span><span class="n">?path</span><span class="p">]]</span><span class="w">
    </span><span class="p">[(</span><span class="nf">acted-with-1</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
    </span><span class="p">[(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="n">?pp</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?p2</span><span class="p">)</span><span class="w">
     </span><span class="p">[(</span><span class="nb">butlast</span><span class="w"> </span><span class="n">?pp</span><span class="p">)</span><span class="w"> </span><span class="n">?p1</span><span class="p">]</span><span class="w">
     </span><span class="p">[(</span><span class="nb">concat</span><span class="w"> </span><span class="n">?p1</span><span class="w"> </span><span class="n">?p2</span><span class="p">)</span><span class="w"> </span><span class="n">?path</span><span class="p">]]])</span><span class="w">

</span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?path</span><span class="w">
     </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
     </span><span class="no">:where</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?a1</span><span class="w"> </span><span class="n">?a2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; #{[(17592186887476 17592186434418 17592187362817 17592186339273 17592186838882)] [(17592186887476 17592186434418 17592188400376 17592186529535 17592186838882)] [(17592186887476 17592186434418 17592187854963 17592186529535 17592186838882)] [(17592186887476 17592186434418 17592186926035 17592186302397 17592186838882)]}
</span></code></pre>

<p>This time we get back a collection of paths with entity ids. We can easily
transform these ids by mapping them into entities and getting the name or title,
using a function like the following:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">ent</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entity</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="no">:movie/title</span><span class="w"> </span><span class="n">ent</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:person/name</span><span class="w"> </span><span class="n">ent</span><span class="p">))))</span><span class="w">
</span></code></pre>

<p>So, putting the query together with the above function, we get:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
      </span><span class="nb">name</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="n">d</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?path</span><span class="w">
            </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
            </span><span class="no">:where</span><span class="w">
            </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?a1</span><span class="w"> </span><span class="n">?a2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
          </span><span class="n">d</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">mapv</span><span class="w"> </span><span class="nb">name</span><span class="p">))))</span><span class="w">
</span><span class="c1">;=&gt; (["Bieber, Justin" "Men in Black 3 (2012)" "Jones, Tommy Lee" "JFK (1991)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Howard, Rosemary (II)" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Segal, Tobias" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Brolin, Josh" "Hollow Man (2000)" "Bacon, Kevin (I)"])
</span></code></pre>

<p>The rules above are defined statically, but they are simply clojure data
structures: it would be trivial to generate those rules to an arbitrary
depth. For an example of doing just that, see the <a href="https://github.com/Datomic/mbrainz-sample/blob/master/src/clj/datomic/samples/mbrainz/rules.clj">Datomic mbrainz
sample</a>.</p>

<h2>Low-level traversal for better performance</h2>

<p>Having to know the depth at which to traverse the graph is cumbersome. Datomic
has a distinct advantage of being able to treat your data as local, even if its
permanent storage lives somewhere else. That means that we can bring our own
functions to the problem and execute locally, rather than on a database server.
We can leverage Datomic&rsquo;s <a href="http://docs.datomic.com/clojure/#datomic.api/datoms"><code>datoms</code> function</a> to search the graph using
our own graph-searching algorithm, rather than relying on the query engine.</p>

<p>Our IMDb actor data is essentially a dense unweighted graph. Because of its
density, a <a href="http://en.wikipedia.org/wiki/Bidirectional_search">bidirectional</a> <a href="http://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a> is probably the most
efficient alogrithm for finding the shortest paths from one point to another. A
generic bidirectional BFS returning all shortest paths might look like this.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">paths</span><span class="w">
  </span><span class="s">"Returns a lazy seq of all non-looping path vectors starting with
  [&lt;start-node&gt;]"</span><span class="w">
  </span><span class="p">[</span><span class="n">nodes-fn</span><span class="w"> </span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">this-node</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="nb">path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nodes-fn</span><span class="w"> </span><span class="n">this-node</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">not-any?</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="p">[</span><span class="n">this-node</span><span class="w"> </span><span class="n">%</span><span class="p">]))</span><span class="w">
                            </span><span class="p">(</span><span class="nf">partition</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">path</span><span class="p">)))</span><span class="w">
         </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">paths</span><span class="w"> </span><span class="n">nodes-fn</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="nb">path</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w">
         </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nb">path</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">trace-paths</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">start</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">m</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">paths</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">[</span><span class="n">start</span><span class="p">])))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">find-paths</span><span class="w"> </span><span class="p">[</span><span class="n">from-map</span><span class="w"> </span><span class="n">to-map</span><span class="w"> </span><span class="n">matches</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">matches</span><span class="w">
        </span><span class="n">from</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">reverse</span><span class="w"> </span><span class="p">(</span><span class="nf">trace-paths</span><span class="w"> </span><span class="n">from-map</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w">
        </span><span class="n">to</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="nf">trace-paths</span><span class="w"> </span><span class="n">to-map</span><span class="w"> </span><span class="n">n</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">to</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">neighbor-pairs</span><span class="w"> </span><span class="p">[</span><span class="n">neighbors</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="n">q</span><span class="w">
        </span><span class="n">nbr</span><span class="w"> </span><span class="p">(</span><span class="nf">neighbors</span><span class="w"> </span><span class="nb">node</span><span class="p">)</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">coll</span><span class="w"> </span><span class="n">nbr</span><span class="p">))]</span><span class="w">
    </span><span class="p">[</span><span class="n">nbr</span><span class="w"> </span><span class="nb">node</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bidirectional-bfs</span><span class="w"> </span><span class="p">[</span><span class="n">start</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">neighbors</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">find-pairs</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">neighbor-pairs</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w">
        </span><span class="n">overlaps</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">coll</span><span class="w"> </span><span class="n">q</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">coll</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">)))</span><span class="w">
        </span><span class="n">map-set-pairs</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="w"> </span><span class="n">pairs</span><span class="p">]</span><span class="w">
                        </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="w"> </span><span class="p">[</span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="p">]]</span><span class="w">
                                  </span><span class="p">(</span><span class="nf">assoc!</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="o">#</span><span class="p">{})</span><span class="w"> </span><span class="nb">val</span><span class="p">)))</span><span class="w">
                                </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="nb">map</span><span class="p">)</span><span class="w"> </span><span class="n">pairs</span><span class="p">)))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">preds</span><span class="w"> </span><span class="p">{</span><span class="n">start</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="c1">; map of outgoing nodes to where they came from
</span><span class="w">           </span><span class="n">succs</span><span class="w"> </span><span class="p">{</span><span class="n">end</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">   </span><span class="c1">; map of incoming nodes to where they came from
</span><span class="w">           </span><span class="n">q1</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w">   </span><span class="c1">; queue of outgoing things to check
</span><span class="w">           </span><span class="n">q2</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">end</span><span class="p">)]</span><span class="w">    </span><span class="c1">; queue of incoming things to check
</span><span class="w">      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">q1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">q2</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">q1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">q2</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">find-pairs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">preds</span><span class="p">)</span><span class="w">
                </span><span class="n">preds</span><span class="w"> </span><span class="p">(</span><span class="nf">map-set-pairs</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">pairs</span><span class="p">)</span><span class="w">
                </span><span class="n">q1</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">pairs</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="nf">overlaps</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="p">)]</span><span class="w">
              </span><span class="p">(</span><span class="nf">find-paths</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">all</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">q2</span><span class="p">)))</span><span class="w">
          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">find-pairs</span><span class="w"> </span><span class="n">q2</span><span class="w"> </span><span class="n">succs</span><span class="p">)</span><span class="w">
                </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nf">map-set-pairs</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">pairs</span><span class="p">)</span><span class="w">
                </span><span class="n">q2</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">pairs</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="nf">overlaps</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">q2</span><span class="p">)]</span><span class="w">
              </span><span class="p">(</span><span class="nf">find-paths</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">all</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">q2</span><span class="p">))))))))</span><span class="w">
</span></code></pre>

<p>There&rsquo;s a lot of code here, including some optimizations and helper functions.
The important function here is <code>bidirectional-bfs</code>. I won&rsquo;t explain the details
of the algorithm, but at a high level, it takes in a start and end node and a
function to be called on any node to get it&rsquo;s &ldquo;neighbors&rdquo;.</p>

<p>This is a generic, pure function, agnostic of Datomic or our data. In fact, I used
a simple map as the &ldquo;graph&rdquo; while developing this:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">graph</span><span class="w">
  </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="p">]</span><span class="w">
   </span><span class="no">:b</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="no">:d</span><span class="p">]</span><span class="w">
   </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="no">:e</span><span class="p">]</span><span class="w">
   </span><span class="no">:d</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="no">:e</span><span class="p">]</span><span class="w">
   </span><span class="no">:e</span><span class="w"> </span><span class="p">[</span><span class="no">:c</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="no">:f</span><span class="p">]</span><span class="w">
   </span><span class="no">:f</span><span class="w"> </span><span class="p">[]})</span><span class="w">

</span><span class="p">(</span><span class="nf">bidirectional-bfs</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="no">:e</span><span class="w"> </span><span class="n">graph</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; [[:a :b :c :e] [:a :b :d :e]]
</span></code></pre>

<p>To use this generic algorithm with our database, we need a <code>neighbors</code> function.
Depending on whether a node is an &ldquo;actor&rdquo; or a &ldquo;movie&rdquo;, we need to return its
appropriate counterpart. A naive &ldquo;or&rdquo; condition is actually good enough here:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">movie-actors</span><span class="w">
  </span><span class="s">"Given a Datomic database value and a movie id,
  returns ids for actors in that movie."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:e</span><span class="w"> </span><span class="p">(</span><span class="nf">d/datoms</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:vaet</span><span class="w"> </span><span class="n">eid</span><span class="w"> </span><span class="no">:actor/movies</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">actor-movies</span><span class="w">
  </span><span class="s">"Given a Datomic database value and an actor id,
  returns ids for movies that actor was in."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:v</span><span class="w"> </span><span class="p">(</span><span class="nf">d/datoms</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:eavt</span><span class="w"> </span><span class="n">eid</span><span class="w"> </span><span class="no">:actor/movies</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">neighbors</span><span class="w">
  </span><span class="s">"db is database value
  eid is an actor or movie eid"</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">actor-movies</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">movie-actors</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">))))</span><span class="w">

</span></code></pre>

<p>Gluing everything together is a simple matter of partial application:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">find-id-paths</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">target</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">bidirectional-bfs</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="n">db</span><span class="p">)))</span><span class="w">
</span></code></pre>

<p>Given a source entity id and a target entity id, this will return all shortest
paths (ids), much like the query example above. From there, we could map them
to Datomic entities, get their names, or sort the paths using a domain-specific
heuristic. Plugging in the previous example, we might do something like the
following:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
      </span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">d/filter</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">without-documentaries</span><span class="w"> </span><span class="n">d</span><span class="p">))</span><span class="w">
      </span><span class="n">biebs</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entid</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">[</span><span class="no">:actor/name</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="p">])</span><span class="w">
      </span><span class="n">bacon</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entid</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">[</span><span class="no">:actor/name</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">])</span><span class="w">
      </span><span class="nb">name</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="n">d</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">mapv</span><span class="w"> </span><span class="nb">name</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">find-id-paths</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">biebs</span><span class="w"> </span><span class="n">bacon</span><span class="p">)))</span><span class="w">
</span><span class="c1">;=&gt; (["Bieber, Justin" "Men in Black 3 (2012)" "Jones, Tommy Lee" "JFK (1991)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Segal, Tobias" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Brolin, Josh" "Hollow Man (2000)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Howard, Rosemary (II)" "R.I.P.D. (2013)" "Bacon, Kevin (I)"])
</span></code></pre>

<p>This returns the same set of paths as the query method did. However, this
version has the advantage of going to an arbitrary depth.</p>

<p>This is just one example of graph searching with Datomic. Different kinds of
problems and domains could use other algorithms. The idea, though, is that
generic graph searching functions can be used directly, since the data is
effectively local to the peer machine.</p>

<p>For more Clojure implementations of generic graph searching algorithms,
<a href="https://github.com/aysylu/loom">loom&rsquo;s</a> <a href="https://github.com/aysylu/loom/blob/master/src/loom/alg_generic.clj">alg_generic</a> namespace is a great starting point.</p>

<h2>Performance</h2>

<p>I&rsquo;m using the above ideas and functions on IMDB&rsquo;s dataset to power
<a href="http://kevinbacon.us/">kevinbacon.us</a>. Once the peer&rsquo;s index caches are warmed, the performance
is quite good: most searches I&rsquo;ve performed between well-known actors complete
in under a second, and in many cases, under 100 ms. I never got results that
good with Neo4j&rsquo;s cypher query language.</p>

<h2>Source</h2>

<p>The code in this post is based on the <a href="https://github.com/jgdavey/kevin">source</a> for <a href="http://kevinbacon.us/">kevinbacon.us</a>.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Deferring constraints in PostgreSQL]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2013/08/22/deferring-database-constraints/"/>
    <id>http://joshuadavey.com/2013/08/22/deferring-database-constraints/</id>
    <published>2013-08-21T20:00:00-04:00</published>
    <updated>2016-07-06T13:37:11-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Deferring constraints in PostgreSQL" href="http://hashrocket.com/blog/posts/deferring-database-constraints">here</a></em></p>

<p>Database constraints are essential to ensuring data integrity, and you
should use them. Allowing them to be deferrable during transactions
makes them even more convenient. A common scenario in which the database
can help us is in a sortable list implementation. This post outlines
the how and why of deferring database constraints, using a sortable list
domain as an example.</p>

<h1>Modeling lists of sortable items</h1>

<p>Imagine that you have an application with multiple lists. Each list has
items that can be reordered with a drag-and-drop interaction. This can
be modelled in a fairly straightforward manner.</p>

<p>Each list <code>has_many</code> list items, which are ordered by the <code>position</code>
column. Each list&rsquo;s items have a position beginning with 1 and
incrementing with each subsequent item.</p>
<pre><code class="highlight ruby"><span class="c1"># app/models/list.rb</span>
<span class="k">class</span> <span class="nc">List</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:items</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span> <span class="ss">:position</span> <span class="p">},</span> <span class="ss">class_name: </span><span class="s2">"ListItem"</span>
  <span class="n">validates_presence_of</span> <span class="ss">:name</span>
<span class="k">end</span>
</code></pre>
<pre><code class="highlight ruby"><span class="c1"># app/models/list_item.rb</span>
<span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:list</span>
  <span class="n">validates_presence_of</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:list</span><span class="p">,</span> <span class="ss">:position</span>

  <span class="n">before_validation</span> <span class="ss">:ensure_position</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
      <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">ensure_position</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">position</span> <span class="o">||=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">list_id: </span><span class="n">list_id</span><span class="p">).</span><span class="nf">maximum</span><span class="p">(</span><span class="ss">:position</span><span class="p">).</span><span class="nf">to_i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>A couple things are worth noting about the <code>ListItem</code> class. Firstly, we
have <code>update_positions</code>, a class method that accepts an array of ids and
updates each. This method will be called in a <code>sort</code> controller action
as such:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ItemsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">expose</span><span class="p">(</span><span class="ss">:list</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sort</span>
    <span class="c1"># list item ids is an ordered array of ids</span>
    <span class="n">list</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:list_item_ids</span><span class="o">]</span><span class="p">)</span>
    <span class="n">head</span> <span class="ss">:ok</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Secondly, new items don&rsquo;t necessarily know what position they should
have, so we put list items that don&rsquo;t have <code>position</code> at the end of
their respective list, just before validating that the position is
present.</p>

<p>Here are the migrations that we used to create the models&#39; database
tables:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateLists</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:lists</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:list_items</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:list</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:position</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>

      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Notice anything missing? If you said database constraints, you&rsquo;re
correct! Our application is enforcing presence for most attributes, but
our corresponding columns are missing <code>NOT NULL</code> constraints. Also, the
<code>list_id</code> column on <code>list_items</code> is missing a foreign key constraint.</p>

<p>But I&rsquo;d like to focus on another missing constraint. Our domain model has
an implicit requirement that we haven&rsquo;t enforced with either validations
or database constraints: each list item&rsquo;s position should be <em>unique per
list</em>. No two list items in a list should have the same position. That
would make the ordering non-deterministic.</p>

<p>We could add a uniqueness validation for <code>position</code>, scoped to
the <code>list_id</code>. However, as <a title="The Perils of Uniqueness Validations" href="http://robots.thoughtbot.com/post/55689359336/the-perils-of-uniqueness-validations">thoughtbot recently warned</a>,
application-level uniqueness validations are insufficient <em>at best</em>, and
fail completely in concurrent environments.</p>

<p>The <code>position</code> column needs a database-level constraint.</p>

<h1>Adding constraints</h1>

<p>Adding the uniqueness constraint to <code>position</code> is fairly straightforward
in PostgreSQL. We&rsquo;ll just create a new migration with the following:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">AddUniquenessValidationOnListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        add constraint list_item_position unique (list_id, position);
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        drop constraint if exists list_item_position;
</span><span class="no">    SQL</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Let&rsquo;s wrap our <code>UPDATE</code> statements in a transaction so that any failed
<code>UPDATE</code> of the position column will result in none of them being
updated:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This ensures at the database level that positions of items are unique
per list; no two items in the same list can occupy the &ldquo;1&rdquo; position.
With regard to data integrity, this is a huge improvement over our
initial implementation. But it has one drawback: <strong>it doesn&rsquo;t work</strong>.</p>

<p>To illustrate why, imagine a list with the following items:</p>
<pre><code class="highlight plaintext">id | position | name
13 | 1        | Eggs
18 | 2        | Milk
35 | 3        | Bread
</code></pre>

<p>To move Bread to the top of the list, we would pass an array of ids,
<code>[35,13,18]</code> to the <code>update_positions</code> method. This method does a series
of <code>UPDATE</code> statements to the database. For the first id, the one for
Bread, we end up sending an update statement that would look like the
following:</p>
<pre><code class="highlight sql"><span class="k">UPDATE</span> <span class="n">list_items</span> <span class="k">SET</span> <span class="k">position</span><span class="o">=</span><span class="mi">1</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">35</span><span class="p">;</span>
</code></pre>

<p>After this statement is executed in the database, but before we move on
to the next id in the list, Postgres will fail its constraint checks. At
the moment that the <code>UPDATE</code> happens, the data would be:</p>
<pre><code class="highlight plaintext">id | position | name
13 | 1        | Eggs
18 | 2        | Milk
35 | 1        | Bread
</code></pre>

<p>With both Eggs and Bread occupying the same position, the <code>UPDATE</code> fails.
Of course, we know that we want to change the position of Eggs as well,
so that its position would be &ldquo;2&rdquo;, and that collision would not happen.
But at the time that the constraint-check happens, the database doesn&rsquo;t
know this.</p>

<p>Even within a transaction, database uniqueness constraints are enforced
immediately <strong>per row</strong>. It seems our dreams of data integrity are
smashed. If only there were a way to enforce uniqueness constraints at
the end of the transaction, rather than the end of each statement&hellip;</p>

<h1>Deferrable Constraints</h1>

<p>As mentioned before, constraints are immediately enforced. This
behavior can be changed within a transaction by changing a constraints
deferrable characteristics. In PostgreSQL, constraints are assumed to
be <code>NOT DEFERRABLE</code> by default.</p>

<p>However, constraints can also behave as deferrable in one of two ways:
<code>DEFERRABLE INITIALLY IMMEDIATE</code> or <code>DEFERRABLE INITIALLY DEFERRED</code>.
The first part, <code>DEFERRABLE</code>, is what allows the database constraint
behavior to change within transactions. The second part describes what
the default behavior will be within a transaction.</p>

<p>With a constraint that is deferrable, but initially immediate, the
constraint will by default behave just like a non-deferrable constraint,
checking every statement immediately. A constraint that is initially
deferred will, by default, defer its checks until the transaction is
committed. Both of these can change their behavior per-transaction with a
call to <code>SET CONSTRAINTS</code> (<a href="http://www.postgresql.org/docs/9.2/static/sql-set-constraints.html">documentation</a>).</p>

<p>With that information, let&rsquo;s change the definition of the constraint we
defined before:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">AddUniquenessValidationOnListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        add constraint list_item_position unique (list_id, position)
        DEFERRABLE INITIALLY IMMEDIATE;
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        drop constraint if exists list_item_position;
</span><span class="no">    SQL</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>The only thing we&rsquo;ve changed from before is the <code>DEFERRABLE INITIALLY
IMMEDIATE</code> bit. I think it is a good idea to use the <code>INITIALLY
IMMEDIATE</code> option. This will ensure that other parts of our app, and
other consumers of the database will not be surprised by the behavior of
the constraint; it will continue to act a like a normal, non-deferrable
constraint, until we explicitly opt in to the deferral.</p>

<p>We now need to change our transaction block. In our case, the first
database statement within the transaction must be the <code>SET CONSTRAINTS</code>
statement:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">connection</span><span class="p">.</span><span class="nf">execute</span> <span class="s2">"SET CONSTRAINTS list_item_position DEFERRED"</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Having now opted in to deferring our uniqueness constraint, reordering
the items now works as expected. The constraint still ensures that we
don&rsquo;t have two items that occupy the same position, but waits until the
end of the transaction to do that check. We can have our data integrity
cake and eat it too.</p>

<h1>Bonus: deferrable introspection</h1>

<p>Having to name the constraint in two places is a bit of a bummer, and
introduces a coupling that could bite us if the constraint name ever
changed. Knowing that, we leverage PostgreSQL&rsquo;s introspective abilities
to query the constraint names instead.</p>

<p>For example, we can add the following module to our codebase:</p>
<pre><code class="highlight ruby"><span class="c1"># lib/deferrable.rb</span>
<span class="k">module</span> <span class="nn">Deferrable</span>
  <span class="k">def</span> <span class="nf">deferrable_uniqueness_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>
    <span class="n">usage</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'information_schema.constraint_column_usage'</span>
    <span class="n">constraint</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'pg_constraint'</span>
    <span class="n">arel</span> <span class="o">=</span> <span class="n">usage</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:constraint_name</span><span class="o">]</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">constraint</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:constraint_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:conname</span><span class="o">]</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">where</span><span class="p">(</span>
      <span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:contype</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="s1">'u'</span><span class="p">))</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:condeferrable</span><span class="o">]</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:table_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">table_name</span><span class="p">))</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:column_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">column_name</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">connection</span><span class="p">.</span><span class="nf">select_values</span> <span class="n">arel</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">transaction_with_deferred_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">constraints</span> <span class="o">=</span> <span class="n">deferrable_uniqueness_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">).</span><span class="nf">join</span> <span class="s2">","</span>
      <span class="n">connection</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="s2">"SET CONSTRAINTS %s DEFERRED"</span> <span class="o">%</span> <span class="n">constraints</span><span class="p">)</span>
      <span class="k">yield</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>And now change our model to use it:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">extend</span> <span class="no">Deferrable</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction_with_deferred_constraints_on</span><span class="p">(</span><span class="ss">:position</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>And, boom! Less coupling.</p>

<p><strong>NOTE</strong> That&rsquo;s a lot of Arel! Use at your own risk. ;-)</p>

<h1>Example application</h1>

<p>While writing this post, I created a <a href="https://github.com/jgdavey/uniqueness_constraints_example">sample Rails app</a> to iterate
quickly. I used TDD to write the initial approach, and reused the specs
while I &ldquo;refactored&rdquo; the implementation to the subsequent approaches.
Each <a href="https://github.com/jgdavey/uniqueness_constraints_example/commits/master">commit on the master branch</a> more or less follows the
sections above.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[has_one view]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2013/02/12/sql-views-and-activerecord/"/>
    <id>http://joshuadavey.com/2013/02/12/sql-views-and-activerecord/</id>
    <published>2013-02-11T19:00:00-05:00</published>
    <updated>2016-07-06T13:37:29-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="has_one view" href="http://hashrocket.com/blog/posts/sql-views-and-activerecord">here</a></em></p>

<p>Sometimes, aggregating data can become overly complex in a normal
ActiveRecord model. Because Rails works well with SQL views, we can
create associations to SQL views that aggregate data for us, simplifying
our models and potentially speeding up queries.</p>

<h2>Modeling an inbox</h2>

<p>I&rsquo;ve got an inbox. A cat inbox. For real.</p>

<p><img src="https://s3.amazonaws.com/hashrocket-blog-production/inbox.png" /></p>

<p>There are many possible implementations for modeling an inbox. I&rsquo;ve
gone with a relatively simple approach. Two users participate in a
conversation, sending messages back and forth to each other. The
Conversation model has a subject, but the body of the initial message is
part of the Message object.</p>
<pre><code class="highlight ruby"><span class="c1"># app/models/conversation.rb</span>
<span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># fields: to_id, from_id, subject</span>
  <span class="n">belongs_to</span> <span class="ss">:to</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">belongs_to</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">has_many</span> <span class="ss">:messages</span><span class="p">,</span> <span class="ss">dependent: :destroy</span><span class="p">,</span> <span class="ss">inverse_of: :conversation</span>
<span class="k">end</span>

<span class="c1"># app/models/message.rb</span>
<span class="k">class</span> <span class="nc">Message</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># fields: user_id, conversation_id, body</span>
  <span class="n">belongs_to</span> <span class="ss">:conversation</span><span class="p">,</span> <span class="ss">inverse_of: :messages</span>
  <span class="n">belongs_to</span> <span class="ss">:user</span>
<span class="k">end</span>
</code></pre>

<p>After the initial message, the two participants on the conversation send
messages back and forth. A user may have any number of conversations
with other users. As such, the main inbox view must list the
conversations a user is a participant on, as well as some summary
information about that conversation.</p>

<p>For our purposes, we&rsquo;ve decided on an HTML table view with the following
columns:</p>

<ul>
<li>From - Who the original message was sent from</li>
<li>To - The original recipient of the message</li>
<li>Message - the Subject of the conversation, as well as the first line
of the most recent message</li>
<li>Last post - The date/time of the most recent message</li>
<li>Replies - The number of replies on the conversation (excluding the
first message)</li>
</ul>

<p>Although the subject is part of the conversation itself, everything else
comes from its various associations. This is the view, which reveals the
expected interface each conversation object should have:</p>
<pre><code class="highlight haml"><span class="nt">%table</span><span class="nf">#inbox</span>
  <span class="nt">%thead</span>
    <span class="nt">%tr</span>
      <span class="nt">%th</span> From
      <span class="nt">%th</span> To
      <span class="nt">%th</span> Message
      <span class="nt">%th</span> Last post
      <span class="nt">%th</span> Replies
  <span class="nt">%tbody</span>
    <span class="p">-</span> <span class="n">conversations</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">conversation</span><span class="o">|</span>
      <span class="nt">%tr</span>
        <span class="nt">%td</span><span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">from_name</span>
        <span class="nt">%td</span><span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">to_name</span>
        <span class="nt">%td</span>
          <span class="nt">%p</span>
            <span class="nt">%strong</span><span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">subject</span>
            <span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">most_recent_message_body</span>
        <span class="nt">%td</span>
          <span class="p">=</span> <span class="n">time_ago_in_words</span><span class="p">(</span><span class="n">conversation</span><span class="p">.</span><span class="nf">most_recent_message_sent_at</span><span class="p">)</span>
          ago
        <span class="nt">%td</span><span class="p">=</span> <span class="n">conversation</span><span class="p">.</span><span class="nf">reply_count</span>
</code></pre>

<p>Let&rsquo;s explore a typical way to model this in our model directly.</p>

<h2>A typical Ruby implementation</h2>
<pre><code class="highlight ruby"><span class="c1"># app/models/conversation.rb</span>
<span class="k">class</span> <span class="nc">Converation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># associations, etc...</span>

  <span class="k">def</span> <span class="nf">most_recent_message_body</span>
    <span class="n">most_recent_message</span><span class="p">.</span><span class="nf">body</span> <span class="k">if</span> <span class="n">most_recent_message</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">most_recent_message_sent_at</span>
    <span class="n">most_recent_message</span><span class="p">.</span><span class="nf">created_at</span> <span class="k">if</span> <span class="n">most_recent_message</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">reply_count</span>
    <span class="n">messages</span><span class="p">.</span><span class="nf">size</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_name</span>
    <span class="n">to</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">from_name</span>
    <span class="n">from</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">most_recent_message</span>
    <span class="vi">@most_recent_message</span> <span class="o">||=</span> <span class="n">messages</span><span class="p">.</span><span class="nf">by_date</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># app/models/message.rb</span>
<span class="k">class</span> <span class="nc">Message</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># associations, etc...</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">by_date</span>
    <span class="n">order</span><span class="p">(</span><span class="s2">"created_at DESC"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This approach is fairly straightforward. We obtain the
<code>most_recent_message_body</code> and <code>most_recent_message_sent_at</code> from the
most recent message, which is trivial after we&rsquo;ve ordered the <code>messages</code>
association by date. The <code>to_name</code> and <code>from_name</code> methods are delegated
to their respective associations. And <code>reply_count</code> is simple the total
number of messages, minus one (the initial message doesn&rsquo;t count as a
&ldquo;reply&rdquo;).</p>

<p>This approach offers a number of advantages. For one, it is familiar.
I believe most Rails developers would be able to understand exactly
what&rsquo;s going on above. It also locates all of the domain logic within
the <code>Conversation</code> model, making it easy to find.</p>

<p>Having everything in the <code>Conversation</code> model is actually a blessing
and a curse. Although everything is easy to find, the model is also
quickly becoming bloated. It may not seem like much right now, but as
more information is added to the inbox, it will become unruly.</p>

<p>The other problem with the above is the multitude of N+1 queries that
it has introduced. With only 3 conversations in play, loading the inbox
outputs a log like this:</p>
<pre><code class="highlight plaintext">Started GET "/" for 127.0.0.1 at 2013-02-11 09:49:02 -0600
Connecting to database specified by database.yml
Processing by InboxesController#show as HTML
  User Load (12.8ms)  SELECT "users".* FROM "users" LIMIT 1
  Conversation Load (0.6ms)  SELECT "conversations".* FROM "conversations" WHERE (1 IN (from_id, to_id))
  User Load (18.3ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 2 LIMIT 1
  User Load (0.5ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1
  Message Load (12.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 7 ORDER BY created_at DESC LIMIT 1
   (0.6ms)  SELECT COUNT(*) FROM "messages" WHERE "messages"."conversation_id" = 7
  User Load (0.4ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 3 LIMIT 1
  CACHE (0.0ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 8 ORDER BY created_at DESC LIMIT 1
   (0.4ms)  SELECT COUNT(*) FROM "messages" WHERE "messages"."conversation_id" = 8
  CACHE (0.0ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 1 LIMIT 1
  CACHE (0.0ms)  SELECT "users".* FROM "users" WHERE "users"."id" = 2 LIMIT 1
  Message Load (0.5ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 9 ORDER BY created_at DESC LIMIT 1
   (0.4ms)  SELECT COUNT(*) FROM "messages" WHERE "messages"."conversation_id" = 9
  Rendered inboxes/show.html.haml within layouts/application (683.9ms)
Completed 200 OK in 691ms (Views: 272.5ms | ActiveRecord: 418.1ms)
</code></pre>

<h2>Eager-loading</h2>

<p>We can definitely cut down on the N+1 query problem by introducing eager
loading. In our controller, the <code>conversations</code> exposure is currently
defined thusly:</p>
<pre><code class="highlight ruby"><span class="c1"># app/controllers/inboxes_controller.rb</span>
<span class="k">class</span> <span class="nc">InboxesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">expose</span><span class="p">(</span><span class="ss">:user</span><span class="p">)</span> <span class="p">{</span> <span class="no">User</span><span class="p">.</span><span class="nf">first</span> <span class="p">}</span>
  <span class="n">expose</span><span class="p">(</span><span class="ss">:conversations</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">conversations</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>

<p>Let&rsquo;s change that to eagerly load its associations:</p>
<pre><code class="highlight ruby">  <span class="n">expose</span><span class="p">(</span><span class="ss">:conversations</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">conversations</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:messages</span><span class="p">,</span> <span class="ss">:to</span><span class="p">,</span> <span class="ss">:from</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>With eager-loading in place, the log now looks slightly more reasonable:</p>
<pre><code class="highlight plaintext">Started GET "/" for 127.0.0.1 at 2013-02-11 09:55:24 -0600
Processing by InboxesController#show as HTML
  User Load (0.3ms)  SELECT "users".* FROM "users" LIMIT 1
  Conversation Load (0.3ms)  SELECT "conversations".* FROM "conversations" WHERE (1 IN (from_id, to_id))
  Message Load (0.3ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" IN (7, 8, 9)
  User Load (0.2ms)  SELECT "users".* FROM "users" WHERE "users"."id" IN (1, 2)
  User Load (0.2ms)  SELECT "users".* FROM "users" WHERE "users"."id" IN (2, 3, 1)
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 7 ORDER BY created_at DESC LIMIT 1
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 8 ORDER BY created_at DESC LIMIT 1
  Message Load (0.3ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 9 ORDER BY created_at DESC LIMIT 1
  Rendered inboxes/show.html.haml within layouts/application (9.5ms)
Completed 200 OK in 13ms (Views: 10.0ms | ActiveRecord: 2.4ms)
</code></pre>

<p>There are more optimizations we could make here in Ruby land. But data
transformation and aggregation is something that databases are good at.
We can use a native feature of SQL to aggregate information for us:
views.</p>

<h2>SQL views</h2>

<p>A SQL view is essentially a virtual table. It can be queried just like a
normal table, but does not physically store anything itself. Instead, a
view has a query definition that it uses to represent its data.</p>

<p>In our case, SQL views can allow us to treat a complex SQL query as a
table, abstracting away the complexity into view itself. SQL views are
also read-only, and therefore are usually only used for querying, but
not updating data directly.</p>

<p>ActiveRecord plays nicely with SQL views out of the box. It considers a
SQL view a normal table, and all associations and querying methods work
like they would with a normal table, with one exception: the records are
read-only.</p>

<h2>Add a migration for the view</h2>

<p>Let&rsquo;s create a view to handle the <code>to_name</code> and <code>from_name</code> methods on
conversation. We can do this in a normal migration, but it needs to be
created with raw SQL:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateConversationSummaries</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      CREATE VIEW conversation_summaries AS
        SELECT ...
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="s1">'DROP VIEW conversation_summaries'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This is the basic syntax for adding a view with ActiveRecord migrations.
Our view needs to incorporate <code>to_name</code> and <code>from_name</code>, so let&rsquo;s add
those fields:</p>
<pre><code class="highlight sql"><span class="k">CREATE</span> <span class="k">VIEW</span> <span class="n">conversation_summaries</span> <span class="k">AS</span>
  <span class="k">SELECT</span> <span class="k">c</span><span class="p">.</span><span class="n">id</span><span class="p">,</span>
  <span class="n">f</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">from_name</span><span class="p">,</span>
  <span class="n">t</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">to_name</span>
  <span class="k">FROM</span> <span class="n">conversations</span> <span class="k">c</span>
  <span class="k">inner</span> <span class="k">join</span> <span class="n">users</span> <span class="n">t</span> <span class="k">on</span> <span class="n">t</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">to_id</span>
  <span class="k">inner</span> <span class="k">join</span> <span class="n">users</span> <span class="n">f</span> <span class="k">on</span> <span class="n">f</span><span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="k">c</span><span class="p">.</span><span class="n">from_id</span>
</code></pre>

<p>After we migrate our database, we can use our database console to verify
that we see what we expect:</p>
<pre><code class="highlight plaintext">mailbox_development=# select * from conversation_summaries;
 id |    from_name    |     to_name
----+-----------------+-----------------
  7 | Felionel Richie | Cat Stevens
  8 | Nelly Purrtado  | Cat Stevens
  9 | Cat Stevens     | Felionel Richie
(3 rows)
</code></pre>

<p>Cool. The <code>id</code> corresponds to the conversation, and <code>to_name</code> and
<code>from_name</code> columns come from the users table, but it&rsquo;s all displayed to
us as one table.</p>

<h2>ActiveRecord associations for views</h2>

<p>Now that our view exists, we can integrate it into our application:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">class</span> <span class="nc">Summary</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">table_name</span> <span class="o">=</span> <span class="s2">"conversation_summaries"</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="s2">"id"</span>
    <span class="n">belongs_to</span> <span class="ss">:conversation</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"id"</span>
  <span class="k">end</span>

  <span class="n">has_one</span> <span class="ss">:summary</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"id"</span>
<span class="k">end</span>
</code></pre>

<p>Let&rsquo;s break down what&rsquo;s going on here.</p>

<p>I&rsquo;ve chosen to nest the Summary model within the Conversation
namespace, mostly to call out the fact that we&rsquo;re doing something
non-standard. Also, the Summary class only makes sense in the context of
a Conversation. For that reason, we need to manually set the name of the
table.</p>

<p>We must also choose a primary key, because Rails cannot infer it for SQL
views. The association itself should be familiar. It works like a normal
<code>has_one</code>/<code>belongs_to</code> relationship, except that we override the foreign
key.</p>

<p>Now that the relationships are set up, let&rsquo;s actually take advantage
of our new view by changing the implementation of the <code>to_name</code> and
<code>from_name</code> methods.</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>

  <span class="k">def</span> <span class="nf">to_name</span>
    <span class="c1"># Used to be to.name</span>
    <span class="n">summary</span><span class="p">.</span><span class="nf">to_name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">from_name</span>
    <span class="c1"># Used to be from.name</span>
    <span class="n">summary</span><span class="p">.</span><span class="nf">from_name</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>One the biggest benefits about this approach is that we can <em>eager-load
a view assocation</em>. We no longer need the <code>to</code> or <code>from</code> associations
eager-loaded, since we are no longer using any attributes from them in
the view. Let&rsquo;s update our controller&rsquo;s exposure to only eager-load the
necessary parts:</p>
<pre><code class="highlight ruby"><span class="n">expose</span><span class="p">(</span><span class="ss">:conversations</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">conversations</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:summary</span><span class="p">,</span> <span class="ss">:messages</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>And when we visit the inbox again, the log looks like this:</p>
<pre><code class="highlight plaintext">Started GET "/" for 127.0.0.1 at 2013-02-11 14:26:12 -0600
Processing by InboxesController#show as HTML
  User Load (0.5ms)  SELECT "users".* FROM "users" LIMIT 1
  Conversation Load (0.4ms)  SELECT "conversations".* FROM "conversations" WHERE (1 IN (from_id, to_id))
  Conversation::Summary Load (0.6ms)  SELECT "conversation_summaries".* FROM "conversation_summaries" WHERE "conversation_summaries"."id" IN (7, 8, 9)
  Message Load (0.3ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" IN (7, 8, 9)
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 7 ORDER BY created_at DESC LIMIT 1
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 8 ORDER BY created_at DESC LIMIT 1
  Message Load (0.4ms)  SELECT "messages".* FROM "messages" WHERE "messages"."conversation_id" = 9 ORDER BY created_at DESC LIMIT 1
  Rendered inboxes/show.html.haml within layouts/application (10.4ms)
Completed 200 OK in 13ms (Views: 9.5ms | ActiveRecord: 2.9ms)
</code></pre>

<p>That&rsquo;s definitely an improvement, albeit a small one. We&rsquo;ve pushed data
from the user model into our SQL view, but we don&rsquo;t need to stop there.</p>

<h2>Push it down!</h2>

<p>Let&rsquo;s update our view migration to include more aggregated information
about each conversation.</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateConversationSummaries</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      CREATE VIEW conversation_summaries AS
        SELECT c.id,
        f.name as from_name,
        t.name as to_name,
        m.body as most_recent_message_body,
        m.created_at as most_recent_message_sent_at,
        (select count(*) from messages m2 where m2.conversation_id = c.id) - 1 as reply_count
        FROM conversations c
        inner join users t on t.id = c.to_id
        inner join users f on f.id = c.from_id
        left outer join (
          select distinct on(conversation_id) conversation_id, body, created_at
          from messages m1
          order by conversation_id, created_at desc
        ) m ON m.conversation_id = c.id
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="s1">'DROP VIEW conversation_summaries'</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>After running <code>rake db:migrate:redo</code>, we can verify that everything is
still working as expect in the database console:</p>
<pre><code class="highlight plaintext">mailbox_development=# select * from conversation_summaries;
 id |    from_name    |     to_name     |        most_recent_message_body        | most_recent_message_sent_at | reply_count 
----+-----------------+-----------------+----------------------------------------+-----------------------------+-------------
  7 | Felionel Richie | Cat Stevens     | Say you. Say meow.                     | 2013-02-08 02:45:27.07712   |           2
  8 | Nelly Purrtado  | Cat Stevens     | Except that I'm a cat                  | 2013-02-05 16:45:27.088292  |           0
  9 | Cat Stevens     | Felionel Richie | I'm sorry that you're feeling that way | 2013-01-30 16:45:27.092443  |           1
(3 rows)
</code></pre>

<p>That&rsquo;s a lot of SQL! But actually, all I&rsquo;ve added are one join to a
subquery, and a subselect. Let&rsquo;s review both of these changes.</p>

<p>There are many ways to grab the most recent message for a conversation
in SQL, including using <a href="http://blog.hashrocket.com/posts/sql-window-functions">window functions</a>. The method I&rsquo;ve opted for
here is a <a title="Postgresql documentation" href="http://www.postgresql.org/docs/9.2/static/queries-table-expressions.html#QUERIES-SUBQUERIES">subquery in the table expression</a>. The subquery
alone would return rows for only the most recent messages for each
conversation:</p>
<pre><code class="highlight plaintext">conversation_id |                  body                  |         created_at
----------------+----------------------------------------+----------------------------
              7 | Say you. Say meow.                     | 2013-02-08 02:45:27.07712
              8 | Except that I'm a cat                  | 2013-02-05 16:45:27.088292
              9 | I'm sorry that you're feeling that way | 2013-01-30 16:45:27.092443
</code></pre>

<p>By joining with only the most recent message per conversation, we avoid
duplicate rows and only get the <code>body</code> and <code>created_at</code> columns from
the most recent message. Then, joining against this subquery, we can
add the <code>body</code> and <code>created_at</code> to the list of projections, naming
them <code>most_recent_message_body</code> and <code>most_recent_message_sent_at</code>,
respectively.</p>

<p>The other thing we&rsquo;ve added to the view this iteration is the
<code>reply_count</code> column, which is a subselect to get the count. We also
subtract 1, just as before.</p>

<p>Let&rsquo;s take a look at our Conversation model now:</p>
<pre><code class="highlight ruby"><span class="c1"># before</span>
<span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:to</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">belongs_to</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">has_many</span> <span class="ss">:messages</span><span class="p">,</span> <span class="ss">dependent: :destroy</span><span class="p">,</span> <span class="ss">inverse_of: :conversation</span>

  <span class="k">def</span> <span class="nf">most_recent_message_body</span>
    <span class="n">most_recent_message</span><span class="p">.</span><span class="nf">body</span> <span class="k">if</span> <span class="n">most_recent_message</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">most_recent_message_sent_at</span>
    <span class="n">most_recent_message</span><span class="p">.</span><span class="nf">created_at</span> <span class="k">if</span> <span class="n">most_recent_message</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">reply_count</span>
    <span class="o">[</span><span class="n">messages</span><span class="p">.</span><span class="nf">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]</span><span class="p">.</span><span class="nf">max</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">to_name</span>
    <span class="n">to</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">from_name</span>
    <span class="n">from</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">most_recent_message</span>
    <span class="vi">@most_recent_message</span> <span class="o">||=</span> <span class="n">messages</span><span class="p">.</span><span class="nf">by_date</span><span class="p">.</span><span class="nf">first</span>
  <span class="k">end</span>
<span class="k">end</span>


<span class="c1"># after</span>
<span class="k">class</span> <span class="nc">Conversation</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">class</span> <span class="nc">Summary</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">table_name</span> <span class="o">=</span> <span class="s2">"conversation_summaries"</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">primary_key</span> <span class="o">=</span> <span class="s2">"id"</span>
    <span class="n">belongs_to</span> <span class="ss">:conversation</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"id"</span>
  <span class="k">end</span>

  <span class="n">belongs_to</span> <span class="ss">:to</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">belongs_to</span> <span class="ss">:from</span><span class="p">,</span> <span class="ss">class_name: </span><span class="s2">"User"</span>
  <span class="n">has_many</span> <span class="ss">:messages</span><span class="p">,</span> <span class="ss">dependent: :destroy</span><span class="p">,</span> <span class="ss">inverse_of: :conversation</span>
  <span class="n">has_one</span> <span class="ss">:summary</span><span class="p">,</span> <span class="ss">foreign_key: </span><span class="s2">"id"</span>

  <span class="n">delegate</span> <span class="ss">:most_recent_message_sent_at</span><span class="p">,</span> <span class="ss">:most_recent_message_body</span><span class="p">,</span>
    <span class="ss">:reply_count</span><span class="p">,</span> <span class="ss">:to_name</span><span class="p">,</span> <span class="ss">:from_name</span><span class="p">,</span> <span class="ss">to: :summary</span>

<span class="k">end</span>
</code></pre>

<p>With much of our data transformation and aggregation in our SQL view,
our model has become trivially simple. It literally only contains
assocations and delegation now. We update our exposure to only
eager-load the conversation summary:</p>
<pre><code class="highlight ruby"><span class="n">expose</span><span class="p">(</span><span class="ss">:conversations</span><span class="p">)</span> <span class="p">{</span> <span class="n">user</span><span class="p">.</span><span class="nf">conversations</span><span class="p">.</span><span class="nf">includes</span><span class="p">(</span><span class="ss">:summary</span><span class="p">)</span> <span class="p">}</span>
</code></pre>

<p>Now, reloading the page yields the following log output:</p>
<pre><code class="highlight plaintext">Started GET "/" for 127.0.0.1 at 2013-02-11 15:37:49 -0600
Processing by InboxesController#show as HTML
  User Load (1.0ms)  SELECT "users".* FROM "users" LIMIT 1
  Conversation Load (0.2ms)  SELECT "conversations".* FROM "conversations" WHERE (1 IN (from_id, to_id))
  Conversation::Summary Load (0.8ms)  SELECT "conversation_summaries".* FROM "conversation_summaries" WHERE "conversation_summaries"."id" IN (7, 8, 9)
  Rendered inboxes/show.html.haml within layouts/application (5.5ms)
Completed 200 OK in 8ms (Views: 6.0ms | ActiveRecord: 2.0ms)
</code></pre>

<p>Now we see some real improvement. All N+1 queries are gone, replaced
instead with the eager-loading of the the Conversation::Summary model.</p>

<h2>Real World Benefits</h2>

<p>I used this technique in a real-world application. It helped abstract
some of the mundane details of the inbox and allowed us to think about
each conversation at a higher level with a summary.</p>

<p>In fact the app included even more business rules than I&rsquo;ve included
here. Each conversation had to include a read/unread status that updated
with each sent message. Although it was easily implemented in pure Ruby,
it cluttered the model and created yet more N+1 queries in the app view.</p>

<p>The inbox also had to be sorted by the most recent message date,
so that the conversation with the most recent activity would
appear first in the list. This kind of sorting without SQL is both
cumbersome and inefficient in Ruby; you have to load all messages
for each conversation. With the SQL view, it was as simple as
changing the scope from <code>user.conversations.include(:summary)</code> to
<code>user.conversations.include(:summary).order(&quot;conversation_summaries.most
_recent_message_sent_at DESC&quot;)</code>.</p>

<h2>Conclusion</h2>

<p>Any time that we push stuff into the database, we make a tradeoff.
In this case, when we move data transformation into the SQL view, we
sacrifice the co-location of the conversation model and the definition
of its summary. With the summary definition located in the database,
there&rsquo;s one extra layer of indirection.</p>

<p>The other tradeoff is that any time we&rsquo;d like to make a non-trivial
change the view, we actually have to create an entirely new view,
replacing the old one. If for example, we knew that our inbox was likely
to change or add fields, the SQL view approach might be too brittle.</p>

<p>On the other hand, we effectively removed N+1 queries from our
application and simplified our model considerably. By abstracting the
conversation&rsquo;s summary into a model backed by a SQL view, we&rsquo;re able
to think of the Summary as an object in its own right. This provides
a cognitive simplification, but also yields performance gains as the
dataset grows.</p>

<p>It may not be right for every situation, but knowing and understanding
how we can use SQL views in our Rails applications adds another tool to
our toolbelt.</p>

<h2>Example app</h2>

<p>As before, while writing this post, I created a <a href="https://github.com/jgdavey/sql_views">sample Rails app</a> to
iterate quickly. I used TDD to write the pure-ruby approach, and reused
the specs while I &ldquo;refactored&rdquo; the implementation to the subsequent
approaches. Of particular note is the <a href="https://github.com/jgdavey/tree-sql-example/commits/master/app/mo
dels/category.rb">history of the Conversation
model</a>, which mirrors the code above.</p>
]]>
    </content>
  </entry>
</feed>
