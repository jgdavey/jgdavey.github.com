<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Awkward and Proud</title>
  <subtitle>Joshua Davey's blog stuff</subtitle>
  <id>http://joshuadavey.com/</id>
  <link href="http://joshuadavey.com/"/>
  <link href="http://joshuadavey.com/atom.xml" rel="self"/>
  <updated>2016-09-29T20:00:00-04:00</updated>
  <author>
    <name>Joshua Davey</name>
  </author>
  <entry>
    <title>
      <![CDATA[Single-Use Tokens in Datomic]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2016/09/30/single-use-tokens-in-datomic/"/>
    <id>http://joshuadavey.com/2016/09/30/single-use-tokens-in-datomic/</id>
    <published>2016-09-29T20:00:00-04:00</published>
    <updated>2018-07-02T09:35:59-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p>Single-use tokens have a variety of security applications. Whether it&rsquo;s
a password-reset token, or capturing a financial transaction, there are
times when something should happen exactly once, atomically. Once a
token is used, it is invalidated.</p>

<p>Doing things exactly once, atomically, is relatively straightforward in
traditional ACID transactional databases: within a transaction, you find
an entity (row) by the token, perform any updates to that entity, and
finally invalidate the token (often by deleting or nullifying it). <sup id="a1"><a href="#f1">1</a></sup></p>

<p>But how can we accomplish some like this in Datomic?</p>

<h2>The World&rsquo;s Worst Singles Network</h2>

<blockquote>
<p>Welcome to WWSN! We&rsquo;re so excited you&rsquo;re here! On WWSN, you can sign up,
sign in, and reset your password. It&rsquo;s so simple!</p>
</blockquote>

<p>Let&rsquo;s say we have a really simple schema. A user has an email address
and a bcrypted password:</p>
<pre><code class="highlight clojure"><span class="p">[{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="w"> </span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:user/email</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/identity</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="w"> </span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:user/crypted-password</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
 </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="w"> </span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:user/single-use-token</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/value</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}]</span><span class="w">
</span></code></pre>

<p>Some initial data might be added like this:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">[{</span><span class="no">:db/id</span><span class="w"> </span><span class="p">(</span><span class="nf">d/tempid</span><span class="w"> </span><span class="no">:db.part/user</span><span class="p">)</span><span class="w">
                   </span><span class="no">:user/email</span><span class="w"> </span><span class="s">"jim@example.com"</span><span class="w">
                   </span><span class="no">:user/crypted-password</span><span class="w"> </span><span class="p">(</span><span class="nf">crypt</span><span class="w"> </span><span class="s">"jello4stapler"</span><span class="p">)}</span><span class="w">
                  </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="p">(</span><span class="nf">d/tempid</span><span class="w"> </span><span class="no">:db.part/user</span><span class="p">)</span><span class="w">
                   </span><span class="no">:user/email</span><span class="w"> </span><span class="s">"pam@example.com"</span><span class="w">
                   </span><span class="no">:user/crypted-password</span><span class="w"> </span><span class="p">(</span><span class="nf">crypt</span><span class="w"> </span><span class="s">"art4evah"</span><span class="p">)}])</span><span class="w">
</span></code></pre>

<p>Later, one of the users wants to reset their password, so we generate a
password reset token and persist it:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">[{</span><span class="no">:db/id</span><span class="w"> </span><span class="p">(</span><span class="nf">d/tempid</span><span class="w"> </span><span class="no">:db.part/user</span><span class="p">)</span><span class="w">
                   </span><span class="no">:user/email</span><span class="w"> </span><span class="s">"jim@example.com"</span><span class="w">
                   </span><span class="no">:user/single-use-token</span><span class="w"> </span><span class="p">(</span><span class="nf">generate-secure-random</span><span class="p">)}])</span><span class="w">
</span></code></pre>

<h2>An initial approach</h2>

<p>After receiving an email, they follow the link that includes the
single-use token in the URL. When they submit their new password, we
look up the user by that token and update them accordingly:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="p">(</span><span class="nf">d/db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
      </span><span class="n">token</span><span class="w"> </span><span class="p">(</span><span class="no">:token</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w">
      </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">d/q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?e</span><span class="w"> </span><span class="nb">.</span><span class="w">
               </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">?token</span><span class="w">
               </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="n">?e</span><span class="w"> </span><span class="no">:user/single-use-token</span><span class="w"> </span><span class="n">?token</span><span class="p">]]</span><span class="w">
              </span><span class="n">db</span><span class="w"> </span><span class="n">token</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">[[</span><span class="no">:db/add</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="no">:user/crypted-password</span><span class="w"> </span><span class="n">new-password</span><span class="p">]</span><span class="w">
                      </span><span class="p">[</span><span class="no">:db/retract</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="no">:user/single-use-token</span><span class="w"> </span><span class="n">token</span><span class="p">]])))</span><span class="w">
</span></code></pre>

<p>But there&rsquo;s a problem with this solution. Even though the new password
is asserted in the same transaction that the token is invalidated, the
opportunity for concurrency problems between threads and/or peers still
exists.</p>

<p>Here&rsquo;s why. In between the time that <code>e</code> is first found by its token
and its new facts are transacted, somebody else could have already used
(and deleted) the token. In other words, even though all writes are
transactional, the reads are not. In practice this is rarely, if ever,
a problem. <code>(d/db conn)</code> will return the most recent version of the
database that the peer can get.</p>

<h2>Croutons are just stale bread</h2>

<p>Let&rsquo;s illustrate this possibility of a stale database introducing a bug:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">stale-db</span><span class="w"> </span><span class="p">(</span><span class="nf">d/db</span><span class="w"> </span><span class="n">conn</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">token</span><span class="w"> </span><span class="n">new-password</span><span class="p">]}</span><span class="w"> </span><span class="n">params</span><span class="w">
      </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">d/q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?e</span><span class="w"> </span><span class="nb">.</span><span class="w">
               </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">?token</span><span class="w">
               </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="n">?e</span><span class="w"> </span><span class="no">:user/single-use-token</span><span class="w"> </span><span class="n">?token</span><span class="p">]]</span><span class="w">
              </span><span class="n">stale-db</span><span class="w"> </span><span class="n">token</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">[[</span><span class="no">:db/add</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="no">:user/crypted-password</span><span class="w"> </span><span class="n">new-password</span><span class="p">]</span><span class="w">
                      </span><span class="p">[</span><span class="no">:db/retract</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="no">:user/single-use-token</span><span class="w"> </span><span class="n">token</span><span class="p">]])))</span><span class="w">

</span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">token</span><span class="w"> </span><span class="p">(</span><span class="no">:token</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w">
      </span><span class="c1">;; this token still exists because we're using and "old" db value
</span><span class="w">      </span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">d/q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?e</span><span class="w"> </span><span class="nb">.</span><span class="w">
               </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">?token</span><span class="w">
               </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="n">?e</span><span class="w"> </span><span class="no">:user/single-use-token</span><span class="w"> </span><span class="n">?token</span><span class="p">]]</span><span class="w">
              </span><span class="n">stale-db</span><span class="w"> </span><span class="n">token</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="w">
    </span><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">[[</span><span class="no">:db/add</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="no">:user/crypted-password</span><span class="w"> </span><span class="s">"somethingelse"</span><span class="p">]</span><span class="w">
                      </span><span class="p">[</span><span class="no">:db/retract</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="no">:user/single-use-token</span><span class="w"> </span><span class="n">token</span><span class="p">]])))</span><span class="w">

</span></code></pre>

<p>The user entity <code>e</code> is found both times because the database value is
immutable. So, the transactions will both succeed.</p>

<p>The astute reader may have noticed something. I said all writes are
transactional, but in the second block of code, we&rsquo;re retracting a value
that&rsquo;s already been retracted. Something must be broken!</p>

<p>Nothing&rsquo;s broken. This tripped me up at first, but it turns out that
retractions work just like assertions with regard to <em>redundancy
elimination</em>.</p>

<h2>The Department of Redundancy Department</h2>

<p>From the Datomic <a href="http://docs.datomic.com/transactions.html#redundancy-elimination">documentation on transactions</a>:</p>

<blockquote>
<p>Redundancy Elimination</p>

<p>A datom is redundant with the current value of the database if
there is a matching datom that differs only by transaction id. If a
transaction would produce redundant datoms, those datoms are filtered
out, and do not appear a second time in either the indexes or the
transaction log.</p>
</blockquote>

<p>In other words, Datomic is eliminating the redundant retraction: we&rsquo;ve
already retracted the token, so the effective datoms of the transaction
only include the <code>[:db/add ...]</code> of the new password. In this particular
use case, retractions cannot be used to safeguard us from using a token
more than once.</p>

<h2>Transaction functions to the rescue</h2>

<p>Datomic&rsquo;s got us covered. I mentioned before that all writes are
transactional, and reads are not. That&rsquo;s actually only true on the
peers. The transactor itself is guaranteed to always have access to the
most recent database value at any time. Among other things, this is what
enables <a href="http://docs.datomic.com/transactions.html#built-in-transaction-functions">built-in database functions</a> like <code>:db.fn/cas</code> to work.</p>

<p>Within a transaction, a database function is used in place of a
<code>:db/add</code> or <code>:db/retract</code>. When the transactor sees a transactor
function, it invokes it and splices the result into the rest of the
transaction. Also, a database function always receives the most recent
<code>db</code> value as it&rsquo;s first argument. Because you have access to the whole
of the Datomic API, you can leverage this <code>db</code> value to do all sorts of
things.</p>

<p>Let&rsquo;s transact the following new schema info into our database:</p>
<pre><code class="highlight clojure"><span class="p">[{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="w"> </span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:db.fn/set-with-token</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"Look up entity by token, set attr and value, and retract token"</span><span class="w">
  </span><span class="no">:db/fn</span><span class="w"> </span><span class="o">#</span><span class="n">db/fn</span><span class="w"> </span><span class="p">{</span><span class="no">:lang</span><span class="w"> </span><span class="s">"clojure"</span><span class="w">
                 </span><span class="no">:params</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">token-attr</span><span class="w"> </span><span class="n">token-value</span><span class="w"> </span><span class="n">attr</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w">
                 </span><span class="no">:code</span><span class="w"> </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">e</span><span class="w"> </span><span class="p">(</span><span class="nf">datomic.api/q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?e</span><span class="w"> </span><span class="nb">.</span><span class="w">
                                                </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">?ta</span><span class="w"> </span><span class="n">?tv</span><span class="w">
                                                </span><span class="no">:where</span><span class="w">
                                                </span><span class="p">[</span><span class="n">?e</span><span class="w"> </span><span class="n">?ta</span><span class="w"> </span><span class="n">?tv</span><span class="p">]]</span><span class="w">
                                              </span><span class="n">db</span><span class="w"> </span><span class="n">token-attr</span><span class="w"> </span><span class="n">token-value</span><span class="p">)]</span><span class="w">
                         </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">e</span><span class="w">
                           </span><span class="p">[[</span><span class="no">:db/add</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">attr</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w">
                            </span><span class="p">[</span><span class="no">:db/retract</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="n">token-attr</span><span class="w"> </span><span class="n">token-value</span><span class="p">]]</span><span class="w">
                           </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">ex-info</span><span class="w"> </span><span class="s">"No entity with that token exists"</span><span class="w">
                                           </span><span class="p">{</span><span class="n">token-attr</span><span class="w"> </span><span class="n">token-value</span><span class="p">}))))}}]</span><span class="w">
</span></code></pre>

<p>This function is more generic than our immediate use-case, but I prefer
to parameterize attributes as well as values in database functions. It
allows us to re-use the database function for other token fields, and
won&rsquo;t have to be updated in the schema if we ever change the name our
token attribute.</p>

<p>Here&rsquo;s how we use this shiny new function:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">token</span><span class="w"> </span><span class="n">new-password</span><span class="p">]}</span><span class="w"> </span><span class="n">params</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">[[</span><span class="no">:db.fn/set-with-token</span><span class="w"> </span><span class="no">:user/single-use-token</span><span class="w"> </span><span class="n">token</span><span class="w">
                                           </span><span class="no">:user/crypted-password</span><span class="w"> </span><span class="n">new-password</span><span class="p">]]))</span><span class="w">
</span></code></pre>

<p>When we transact this data, the transactor invokes our function using
the most recent database value. In other words, we are making the lookup
portion serializable with the rest of the operations.</p>

<p>If we run this transaction a second time, we&rsquo;ll get the error message.</p>

<h2>In Summary</h2>

<p>This kind of transaction atomicity is made possible by Datomic&rsquo;s
single-writer design. Other database systems (e.g. SQL) have to employ
very complicated isolation patterns like MVVC to allow multiple writers
while keeping data integrity guarantees. Datomic side-steps those problems by
using a single writer, paired with immutable history.</p>

<p>The catch, as we have seen, is that read-dependent writes will require
the use of database functions to maintain atomicity. Of course, database
functions have uses outside of concurrency contexts. And, as a bonus,
they can be loaded and invoked on the client as well.</p>

<p>For more information on database functions, see <a href="http://docs.datomic.com/database-functions.html">the
docs</a>, <a href="https://www.youtube.com/watch?v=8fY687k7DMA">watch
the video</a>,
or see <a href="https://github.com/Datomic/day-of-datomic/blob/master/tutorial
/data_functions.clj">the Day of Datomic
examples</a>. You can also view my <a href="https://gist.github.com/jgdavey/f40731172553724fc86ce270776c7932">scratch.clj</a> file that I
used to build up the code examples here.</p>

<p><sup id="f1">1</sup> However, even in SQL setups there are potential
pitfalls. Because of the potential for multiple writers, care must be
taken to satisfy the &ldquo;exactly once&rdquo; requirement. Where possible, a SQL
client should use a single statement to find, update, and nullify a
token. When a single statement isn&rsquo;t possible, the use of row-level
locks can be used. Or, better yet, wrap everything in a transaction with
serializable isolation level.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Bulk imports with Datomic]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2015/09/17/bulk-imports-with-datomic/"/>
    <id>http://joshuadavey.com/2015/09/17/bulk-imports-with-datomic/</id>
    <published>2015-09-16T20:00:00-04:00</published>
    <updated>2018-07-02T09:35:59-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Bulk imports with Datomic" href="https://hashrocket.com/blog/posts/bulk-imports-with-datomic">here</a></em></p>

<p>I&rsquo;ve been really happy with Datomic, but doing an initial bulk import
wasn&rsquo;t as familiar as SQL dump/restore. Here are some things that I&rsquo;ve
learned from doing several imports.</p>

<h2>Use core.async</h2>

<p>The Datomic transactor handles concurrency by transacting datoms
serially, but that doesn&rsquo;t mean it isn&rsquo;t fast! In my experience, the bottleneck is actually in the
reshaping of data and formatting transactions. I
use <code>core.async</code> to parallelize just about everything in the import
pipeline.</p>

<p>One example of how I&rsquo;ve leveraged <code>core.async</code> for
import jobs can be found in my <a href="https://github.com/jgdavey/kevin/blob/master/src/kevin/loader.clj">Kevin Bacon project
repository</a>.</p>

<h2>Run the import locally</h2>

<p>I use DynamoDB as my storage backend in production. I used to try to
run my import tasks directly to the production transactor/storage.
Lately, though, I&rsquo;ve found it really helpful to run my import tasks to
a locally-running transactor and the <code>dev</code> storage backend.</p>

<p>Running an import locally means I don&rsquo;t have to worry about networking, which speeds the whole process up quite a bit; also, it give me a much more freedom to iterate on the database
design itself. (I rarely get an import correct the first time.) And
in the case of DynamoDB, I save some money, as I don&rsquo;t have to have my
&ldquo;write throughput&rdquo; cranked way up for as long.</p>

<h2>Clean up the local database</h2>

<p>Bulk imports create some garbage, so manually reindexing before backing
up is advantageous. Here&rsquo;s what a REPL session looks like:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">d/connect</span><span class="w"> </span><span class="err">"</span><span class="n">datomic</span><span class="no">:dev://localhost:4334/database-name</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="nf">d/request-index</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="n">d/db</span><span class="w"> </span><span class="n">d/basis-t</span><span class="w"> </span><span class="p">(</span><span class="nf">d/sync-index</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="nb">deref</span><span class="p">)</span><span class="w">
</span><span class="c1">;; blocks until done indexing
</span><span class="p">(</span><span class="nf">d/gc-storage</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.Date.</span><span class="p">))</span><span class="w">
</span></code></pre>

<p>For more information on why this cleanup
is important, see <a href="http://docs.datomic.com/capacity.html#sec-2-4">the relevant Datomic
documentation</a>.</p>

<h2>Use backup/restore</h2>

<p>Once everything looks good on the local production database, I use
Datomic&rsquo;s builtin backup/restore facilities to send the database
up to production. Assuming you&rsquo;ve already deployed a production transactor and provisioned DynamoDB storage, here&rsquo;s the process I follow:</p>

<ol>
<li>Run the <code>datomic backup-db</code> command against the local import.</li>
<li>Crank my &ldquo;write throughput&rdquo; on DynamoDB <em>way</em> up (on the order of 1000).</li>
<li>Run the <code>datomic restore-db</code> command from the backup folder to the
remote database.</li>
<li>Turn the &ldquo;write throughput&rdquo; back down to whatever
value I plan to use for ongoing use (see <a href="http://docs.datomic.com/capacity.html#sec-5">the Datomic
documentation</a> for more
information).</li>
</ol>

<p>The heart of almost every business is its data. Datomic is a great
choice for business data, in part because it treats <em>all</em> data as
important: nothing is overwritten. New things are learned, but the old
facts are not replaced. And knowing how to get your data into Datomic
is half the battle.</p>

<p>Go forth and import!</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Boot + Middleman: The ClojureScript development environment of my dreams]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2015/06/04/boot-middleman/"/>
    <id>http://joshuadavey.com/2015/06/04/boot-middleman/</id>
    <published>2015-06-03T20:00:00-04:00</published>
    <updated>2018-07-02T09:35:59-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Boot + Middleman: The ClojureScript development environment of my dreams" href="https://hashrocket.com/blog/posts/the-front-end-development-environment-of-my-dreams">here</a></em></p>

<p>I&rsquo;m getting closer to the frontend development environment of my dreams. The
combination of editor integration, live browser reload, and not having to
manually run commands over and over is time-saving and a pleasure to
work with.</p>

<p>At Hashrocket, designers and developers work very closely
together. Visual design and markup is handled by our
designers, who create &ldquo;stubbed out&rdquo; templates in <a href="http://hashrocket.com/blog/posts/managing-design-handoffs-with-the-ui-controller">the UI
directory</a>.
It&rsquo;s a process that works very well for us, and
allows us to iteratively add features to an application.</p>

<p>This process has served us very well in Rails using a <a href="http://hashrocket.com/blog/posts/managing-design-handoffs-with-the-ui-controller">UI
controller</a>,
available only in development mode.</p>

<p>I&rsquo;ve been using ClojureScript a lot lately, particularly with Om, and
have missed that directory of collaboration. After all, the designers
at Hashrocket have a proclivity for HAML and SASS.</p>

<p>In the past, I&rsquo;ve set up a separate repository using <a href="https://middlemanapp.com">Middleman</a> to
handle markup and styles, using <code>middleman build</code>, copying the generated
CSS files, and eyeballing the generated markup to ensure it matched the
Om component&rsquo;s markup. Aside from being tedious, it&rsquo;s really easy to
get out of sync with a manual process like this. The static resource
generation should be a part of our build process.</p>

<p>Enter <a href="http://boot-clj.com">boot</a>.</p>

<h3>Using Boot for ClojureScript development</h3>

<p>If you&rsquo;re new to the Clojure world, you may have heard of <a href="http://leiningen.org">Leiningen</a>,
which is the de facto dependency management and build tool for
Clojure/Script. Boot is similar to Leiningen, but adds the ability to
compose tasks to create build pipelines. This composability, along with
some really smart architectural decisions, is what makes boot a great
choice for the problem at hand.</p>

<p>Adzerk&rsquo;s <a href="https://github.com/adzerk-oss/boot-cljs-example">example repo</a>
is a great way to get started with ClojureScript and boot. Of particular
note is the <code>build.boot</code> file. It demonstrates how one can build
up a <code>dev</code> task that watches a directory for changes, rebuilding
ClojureScript sources, and notifying the browser to reload the code. It
includes the setup necessary for source maps, a development server,
and the browser-connected REPL. But what I want to add to that pot
of awesome is the ability to compile HAML and SASS as a part of the
pipeline.</p>

<h3>boot-middleman: Gluing Everything Together</h3>

<p>I had an epiphany one night after working on this problem for a while: I
can just use Middleman. After all, boot and the ClojureScript compiler
run on the JVM, and JRuby is easily embeddable. After a short bit, I
came up with <a href="https://github.com/jgdavey/boot-middleman">boot-middleman</a>, the glue I needed to build HAML/SASS as
a part of my build process.</p>

<p>It assumes a subdirectory is a Middleman app (<code>assets</code> by default). This
works nicely because my designer pals can collaborate with me without
having to use the JVM at all. They just run <code>middleman</code> in the <code>assets</code>
subdirectory and work as normal.</p>

<p>See the boot-middleman README for instructions on setting up.</p>

<p>I used this workflow to create a minesweeper clone, <a href="https://github.com/jgdavey/minesweeper">the
source</a> of which is on GitHub.
Just clone and run <code>boot dev</code>.</p>

<h3>The Workflow in Action</h3>

<p>To see the workflow in action, check out the following video. It
demonstrates how editing front-end files do not require a manual browser
refresh to see the effects.</p>

<iframe src="https://player.vimeo.com/video/128494099" width="500" height="280" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Screencast: Clojure + vim basics]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2014/06/13/screencast-clojure-and-vim-basics/"/>
    <id>http://joshuadavey.com/2014/06/13/screencast-clojure-and-vim-basics/</id>
    <published>2014-06-12T20:00:00-04:00</published>
    <updated>2018-07-02T09:35:59-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p>In this screencast I cover how to do basic evaluation and get Clojure
documentation from within vim. I&rsquo;m also including the transcript below.</p>

<iframe src="//player.vimeo.com/video/98052766" width="100%" height="280" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

<p>Vim is a powerful text editor. Clojure is a powerful programming
language. While its been possible to edit Clojure code in vim for years,
the toolchain has improved greatly over the past year. Today we&rsquo;re going
to see how we can integrate vim with our Clojure REPL environment.</p>

<h1>Life without integration</h1>

<p>In a shell session, let&rsquo;s fire up a Clojure REPL. I&rsquo;m going to use <code>lein
repl</code> to do this. In another shell session, let&rsquo;s start vim and edit a
clojure file.</p>

<p>As I edit my file, I can copy code from the editor, switch to the window
with the REPL in it, and paste that code in. This works, but it&rsquo;s an
awkward, slow process. REPLs are supposed to be all about fast feedback.
We can do better than copy and paste.</p>

<h1>Plugins</h1>

<p>Before we get started, we should get the some basic plugins for clojure
development. Using your preferred vim plugin manager, add these plugins:</p>
<pre><code class="highlight plaintext">guns/vim-clojure-static
tpope/fireplace.vim
</code></pre>

<h1>Setup</h1>

<p>After you&rsquo;ve installed the necessary Vim plugins, enter a project
directory. For example, if you have a leiningen project, cd into the
directory. In one shell session, fire up a REPL with <code>lein repl</code>. In
another shell session, cd that that folder once again, and then open
vim.</p>

<p>Fireplace is able to detect when you are in the same directory as an
active REPL, and will attempt to automatically connect for you. This
process is transparent, but should be obvious once we attempt to to send
a command to the connected REPL.</p>

<h1>Evaluation</h1>

<p>The most basic fireplace command is <code>:Eval</code>. <code>:Eval</code> takes an arbitrary
clojure expression, sends it off to the REPL, and prints the result
for you. For example, we could run <code>:Eval (+ 1 1)</code>, and we would, as
expected, see <code>2</code> printed out. This emulates typing at REPL prompt
directly, but there&rsquo;s much more we can do with our REPL-connected vim
session.</p>

<p>Let&rsquo;s stay with <code>:Eval</code> for a bit longer. <code>:Eval</code> without any arguments
will send eval and print the outermost form on the current line. For
example, let&rsquo;s look at a simple expression.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>When we have our cursor on this line and type <code>:Eval</code> with no arguments,
we&rsquo;ll see <code>(2 3 4)</code> printed back.</p>

<p><code>:Eval</code>, as with many vim commands, can also take a range. So,
<code>:1,3Eval</code> would evaluate all of lines 1 through 3. All of the normal
special ranges work here, such as <code>%</code> for the entire file, and <code>&#39;&lt;,&#39;&gt;</code>
for the current selection in visual mode.</p>

<p><code>:Eval</code> works well, but there&rsquo;s a quicker way to get feedback. <code>cp</code> is
the normal mode mapping for doing a simple eval and print. By default,
<code>cp</code> expects a motion. The form that I use most though is <code>cpp</code>, which
will eval and print the innermost form from the cursor&rsquo;s current
position.</p>

<p>To demonstrate what this means, let&rsquo;s look at that expression again.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>When our cursor is on the <code>m</code> of <code>map</code>, and we type <code>cpp</code>, we&rsquo;ll see
<code>(2 3 4)</code>, just as when we did the plain <code>:Eval</code>. But if we move our
cursor inside the vector and type <code>cpp</code> again, we&rsquo;ll see that inner form
evaluated.</p>

<p>Something unique to fireplace is its concept of a quasi-REPL. This is a
cousin of the <code>cp</code> mappings, but with an intermediate editing window. To
demonstrate this, let&rsquo;s consider the following example.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="p">)</span><span class="w">
     </span><span class="nb">reverse</span><span class="w">
     </span><span class="p">(</span><span class="nf">mapv</span><span class="w"> </span><span class="nb">dec</span><span class="p">))</span><span class="w">

</span></code></pre>

<p>In this trivial example, we want to reverse a sequence and decrement
each number. There&rsquo;s a bug in here, but it&rsquo;s in the middle of the
thread-through macro. We could just edit the line directly and
eval/print using <code>cpp</code>, but there&rsquo;s another way to do one-off iterative
development like this.</p>

<p>Type <code>cqc</code> in normal mode. A commandline window will open. This is very
much like a normal vim buffer, with a few notable exceptions:</p>

<ol>
<li>It cannot be modified or saved</li>
<li>Pressing <code>Enter</code> in normal mode sends the current line to the REPL
for eval-ing.</li>
<li>As you run commands, they are added to this buffer.</li>
</ol>

<p>tpope calls this the &ldquo;quasi-repl&rdquo;, and indeed that is the mnemonic for
the mapping itself: <code>cq</code> is the &ldquo;Clojure Quasi-REPL&rdquo;.</p>

<p>While we&rsquo;re in this special window, let&rsquo;s type the following, and hit
enter:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></code></pre>

<p>Immediately, we can see the issue. Converting each number to a string
prevents <code>dec</code> from working later on.</p>

<p>Having to type the whole line again isn&rsquo;t always convenient. For those
cases, there&rsquo;s <code>cqq</code>, which is like <code>cqc</code> except that it pre-populates
the command window with the innermost form under the cursor. We can
see this in action by putting our cursor near the beginning of the
thread-through macro, and typing <code>cqq</code>.</p>

<p>You can think of <code>cqq</code> as being very similar to <code>cpp</code>, but with a chance
to edit the line or lines before sending it off to the REPL.</p>

<h1>Documentation</h1>

<p>One of the great things about Clojure is that documentation is a
first-class citizen, and builtin functions have documentation attached
to them. With a standard REPL, we can use the <code>doc</code> function to get the
signature and documentation for a given function.</p>

<p>With fireplace, we get this with the <code>:Doc</code> command, and it works just
like <code>doc</code>. To see the documentation for <code>map</code>, for example, type <code>:Doc
map</code>. We immediately see the documentation for the map command printed.</p>

<p>There&rsquo;s an even shorter way to look up documentation for a function.
When your cursor is on a word, you can press <code>K</code>, that is <code>Shift</code> and
<code>K</code>. We can try this again with the <code>map</code> function by placing our cursor
on the function itself, and pressing <code>K</code>.</p>

<p>We can also use the <code>:Source</code> command to show the source for a function.
When we do this with <code>map</code>, we see the source code for <code>map</code> from
<code>clojure.core</code>.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Using Datomic as a Graph Database]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2014/04/10/using-datomic-as-a-graph-database/"/>
    <id>http://joshuadavey.com/2014/04/10/using-datomic-as-a-graph-database/</id>
    <published>2014-04-09T20:00:00-04:00</published>
    <updated>2018-07-02T09:43:34-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Using Datomic as a Graph Database" href="http://hashrocket.com/blog/posts/using-datomic-as-a-graph-database">here</a></em></p>

<p>Datomic is a database that changes the way that you think about databases. It
also happens to be effective at modeling graph data and was a great fit for
performing graph traversal in a recent project I built.</p>

<p>I started out building a six degress of Kevin Bacon project using
<a href="http://www.neo4j.org/">Neo4j</a>, a popular open-source graph database. It worked very well
for actors that were a few hops away, but finding paths between actors
with more than 5 hops proved problematic.  The cypher query language
gave me little visibility into the graph algorithms actually being
executed. I wanted more.</p>

<p>Despite not being explicitly labeled as such, Datomic proved to be an effective
graph database. Its ability to arbitrarily traverse datoms, when paired with
the appropriate graph searching algorithm, solved my problem elegantly. This
technique ended up being fast as well.</p>

<p>Quick aside: this post assumes a cursory understanding of Datomic. I won&rsquo;t cover
the basics, but the <a href="http://docs.datomic.com/tutorial.html">official tutorial</a> will help you get started.</p>

<h2>6 Degrees Kevin == Cool; 6 Degrees Kelvin == Cold</h2>

<p>The problem domain should be fairly familiar: <a href="http://en.wikipedia.org/wiki/Six_Degrees_of_Kevin_Bacon">the 6 degrees of Kevin
Bacon</a>. I wanted to create an app where you could pick an
actor and find out what their Bacon Number was. That is, given an actor,
I wanted to answer the question &ldquo;how many degrees of separation is there
between that actor and Kevin Bacon?&rdquo;</p>

<p>Using <a href="http://www.imdb.com/interfaces">information freely available from IMDb</a>, I developed the following
schema:</p>
<pre><code class="highlight clojure"><span class="p">[</span><span class="w">
 </span><span class="c1">;; movies
</span><span class="w"> </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:movie/title</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/identity</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A movie's title (upsertable)"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:movie/year</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/long</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A movie's release year"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="c1">;; actors
</span><span class="w"> </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:person/name</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
  </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
  </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/identity</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"A person's name (upsertable)"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">

 </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
  </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w">
  </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/ref</span><span class="w">
  </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/many</span><span class="w">
  </span><span class="no">:db/doc</span><span class="w"> </span><span class="s">"An actor's ref to a movie"</span><span class="w">
  </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
 </span><span class="p">]</span><span class="w">

</span></code></pre>

<p>In a nutshell, movies have titles and years. Actors have names and movies.
The &ldquo;relationship&rdquo; of actors to movies is many-to-many, so I&rsquo;ve declared the
<code>:actor/movies</code> attribute as having a cardinality of many.</p>

<h2>Using datalog queries</h2>

<p>Using datalog and <code>datomic.api/q</code>, we can make graph-like queries fairly easily.
Because the <code>:where</code> clauses of a datalog query form an implicit join, we can
join from our starting point to our ending point with relative ease.</p>

<p>As an example, what if we wanted to know the shortest path or paths from Kevin
Bacon to Jon Belushi? Let&rsquo;s use a query to find out:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">datomic.api</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">q</span><span class="w"> </span><span class="n">db</span><span class="p">]])</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">conn</span><span class="w"> </span><span class="p">(</span><span class="nf">d/connect</span><span class="w"> </span><span class="n">...</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?title</span><span class="w"> </span><span class="n">?end</span><span class="w">
      </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
      </span><span class="no">:where</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?m</span><span class="w"> </span><span class="no">:movie/title</span><span class="w"> </span><span class="n">?title</span><span class="p">]]</span><span class="w">
    </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
    </span><span class="s">"Bacon, Kevin (I)"</span><span class="w">
    </span><span class="s">"Belushi, John"</span><span class="p">)</span><span class="w">

</span><span class="c1">;=&gt; #{["Bacon, Kevin (I)" "Animal House (1978)" "Belushi, John"]}
</span></code></pre>

<p>That is fine when actors have worked together in a movie (a Bacon Number of 1),
but doesn&rsquo;t help us solve Bacon numbers when there are 2 or more movies between
the actors. We could add more where clauses to join over two movies, but that
isn&rsquo;t sustainable. The queries would quickly become too long to reason about.
This is a prime opportunity to use Datomic&rsquo;s rules.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w">
  </span><span class="o">'</span><span class="p">[[(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">[</span><span class="n">?e1</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?e2</span><span class="w"> </span><span class="no">:actor/movies</span><span class="w"> </span><span class="n">?m</span><span class="p">]</span><span class="w">
     </span><span class="p">[(</span><span class="nf">!=</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="p">)]</span><span class="w">
     </span><span class="p">[(</span><span class="nb">vector</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?m</span><span class="w"> </span><span class="n">?e2</span><span class="p">)</span><span class="w"> </span><span class="n">?path</span><span class="p">]]</span><span class="w">
    </span><span class="p">[(</span><span class="nf">acted-with-1</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
    </span><span class="p">[(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?path</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?e1</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="n">?pp</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with</span><span class="w"> </span><span class="n">?x</span><span class="w"> </span><span class="n">?e2</span><span class="w"> </span><span class="n">?p2</span><span class="p">)</span><span class="w">
     </span><span class="p">[(</span><span class="nb">butlast</span><span class="w"> </span><span class="n">?pp</span><span class="p">)</span><span class="w"> </span><span class="n">?p1</span><span class="p">]</span><span class="w">
     </span><span class="p">[(</span><span class="nb">concat</span><span class="w"> </span><span class="n">?p1</span><span class="w"> </span><span class="n">?p2</span><span class="p">)</span><span class="w"> </span><span class="n">?path</span><span class="p">]]])</span><span class="w">

</span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?path</span><span class="w">
     </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
     </span><span class="no">:where</span><span class="w">
     </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
     </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?a1</span><span class="w"> </span><span class="n">?a2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; #{[(17592186887476 17592186434418 17592187362817 17592186339273 17592186838882)] [(17592186887476 17592186434418 17592188400376 17592186529535 17592186838882)] [(17592186887476 17592186434418 17592187854963 17592186529535 17592186838882)] [(17592186887476 17592186434418 17592186926035 17592186302397 17592186838882)]}
</span></code></pre>

<p>This time we get back a collection of paths with entity ids. We can easily
transform these ids by mapping them into entities and getting the name or title,
using a function like the following:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">ent</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entity</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="no">:movie/title</span><span class="w"> </span><span class="n">ent</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:person/name</span><span class="w"> </span><span class="n">ent</span><span class="p">))))</span><span class="w">
</span></code></pre>

<p>So, putting the query together with the above function, we get:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
      </span><span class="nb">name</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="n">d</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?path</span><span class="w">
            </span><span class="no">:in</span><span class="w"> </span><span class="n">$</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">?start</span><span class="w"> </span><span class="n">?end</span><span class="w">
            </span><span class="no">:where</span><span class="w">
            </span><span class="p">[</span><span class="n">?a1</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?start</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">?a2</span><span class="w"> </span><span class="no">:actor/name</span><span class="w"> </span><span class="n">?end</span><span class="p">]</span><span class="w">
            </span><span class="p">(</span><span class="nf">acted-with-2</span><span class="w"> </span><span class="n">?a1</span><span class="w"> </span><span class="n">?a2</span><span class="w"> </span><span class="n">?path</span><span class="p">)]</span><span class="w">
          </span><span class="n">d</span><span class="w"> </span><span class="n">acted-with-rules</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">mapv</span><span class="w"> </span><span class="nb">name</span><span class="p">))))</span><span class="w">
</span><span class="c1">;=&gt; (["Bieber, Justin" "Men in Black 3 (2012)" "Jones, Tommy Lee" "JFK (1991)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Howard, Rosemary (II)" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Segal, Tobias" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Brolin, Josh" "Hollow Man (2000)" "Bacon, Kevin (I)"])
</span></code></pre>

<p>The rules above are defined statically, but they are simply clojure data
structures: it would be trivial to generate those rules to an arbitrary
depth. For an example of doing just that, see the <a href="https://github.com/Datomic/mbrainz-sample/blob/master/src/clj/datomic/samples/mbrainz/rules.clj">Datomic mbrainz
sample</a>.</p>

<h2>Low-level traversal for better performance</h2>

<p>Having to know the depth at which to traverse the graph is cumbersome. Datomic
has a distinct advantage of being able to treat your data as local, even if its
permanent storage lives somewhere else. That means that we can bring our own
functions to the problem and execute locally, rather than on a database server.
We can leverage Datomic&rsquo;s <a href="http://docs.datomic.com/clojure/#datomic.api/datoms"><code>datoms</code> function</a> to search the graph using
our own graph-searching algorithm, rather than relying on the query engine.</p>

<p>Our IMDb actor data is essentially a dense unweighted graph. Because of its
density, a <a href="http://en.wikipedia.org/wiki/Bidirectional_search">bidirectional</a> <a href="http://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a> is probably the most
efficient alogrithm for finding the shortest paths from one point to another. A
generic bidirectional BFS returning all shortest paths might look like this.</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">paths</span><span class="w">
  </span><span class="s">"Returns a lazy seq of all non-looping path vectors starting with
  [&lt;start-node&gt;]"</span><span class="w">
  </span><span class="p">[</span><span class="n">nodes-fn</span><span class="w"> </span><span class="nb">path</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">this-node</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="nb">path</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">nodes-fn</span><span class="w"> </span><span class="n">this-node</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">not-any?</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="p">[</span><span class="n">this-node</span><span class="w"> </span><span class="n">%</span><span class="p">]))</span><span class="w">
                            </span><span class="p">(</span><span class="nf">partition</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nb">path</span><span class="p">)))</span><span class="w">
         </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">paths</span><span class="w"> </span><span class="n">nodes-fn</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="nb">path</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w">
         </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="nb">path</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">trace-paths</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">start</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">remove</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">m</span><span class="w"> </span><span class="p">(</span><span class="nb">peek</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">paths</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="p">[</span><span class="n">start</span><span class="p">])))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">find-paths</span><span class="w"> </span><span class="p">[</span><span class="n">from-map</span><span class="w"> </span><span class="n">to-map</span><span class="w"> </span><span class="n">matches</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="w"> </span><span class="n">matches</span><span class="w">
        </span><span class="n">from</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">reverse</span><span class="w"> </span><span class="p">(</span><span class="nf">trace-paths</span><span class="w"> </span><span class="n">from-map</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w">
        </span><span class="n">to</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">rest</span><span class="w"> </span><span class="p">(</span><span class="nf">trace-paths</span><span class="w"> </span><span class="n">to-map</span><span class="w"> </span><span class="n">n</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">to</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">neighbor-pairs</span><span class="w"> </span><span class="p">[</span><span class="n">neighbors</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">for</span><span class="w"> </span><span class="p">[</span><span class="nb">node</span><span class="w"> </span><span class="n">q</span><span class="w">
        </span><span class="n">nbr</span><span class="w"> </span><span class="p">(</span><span class="nf">neighbors</span><span class="w"> </span><span class="nb">node</span><span class="p">)</span><span class="w">
        </span><span class="no">:when</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">coll</span><span class="w"> </span><span class="n">nbr</span><span class="p">))]</span><span class="w">
    </span><span class="p">[</span><span class="n">nbr</span><span class="w"> </span><span class="nb">node</span><span class="p">]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bidirectional-bfs</span><span class="w"> </span><span class="p">[</span><span class="n">start</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">neighbors</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">find-pairs</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">neighbor-pairs</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span><span class="w">
        </span><span class="n">overlaps</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">coll</span><span class="w"> </span><span class="n">q</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">coll</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">)))</span><span class="w">
        </span><span class="n">map-set-pairs</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="w"> </span><span class="n">pairs</span><span class="p">]</span><span class="w">
                        </span><span class="p">(</span><span class="nf">persistent!</span><span class="w"> </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="nb">map</span><span class="w"> </span><span class="p">[</span><span class="nb">key</span><span class="w"> </span><span class="nb">val</span><span class="p">]]</span><span class="w">
                                  </span><span class="p">(</span><span class="nf">assoc!</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="o">#</span><span class="p">{})</span><span class="w"> </span><span class="nb">val</span><span class="p">)))</span><span class="w">
                                </span><span class="p">(</span><span class="nf">transient</span><span class="w"> </span><span class="nb">map</span><span class="p">)</span><span class="w"> </span><span class="n">pairs</span><span class="p">)))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">[</span><span class="n">preds</span><span class="w"> </span><span class="p">{</span><span class="n">start</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w"> </span><span class="c1">; map of outgoing nodes to where they came from
</span><span class="w">           </span><span class="n">succs</span><span class="w"> </span><span class="p">{</span><span class="n">end</span><span class="w"> </span><span class="n">nil</span><span class="p">}</span><span class="w">   </span><span class="c1">; map of incoming nodes to where they came from
</span><span class="w">           </span><span class="n">q1</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">start</span><span class="p">)</span><span class="w">   </span><span class="c1">; queue of outgoing things to check
</span><span class="w">           </span><span class="n">q2</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="n">end</span><span class="p">)]</span><span class="w">    </span><span class="c1">; queue of incoming things to check
</span><span class="w">      </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">q1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">q2</span><span class="p">))</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">q1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">q2</span><span class="p">))</span><span class="w">
          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">find-pairs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">preds</span><span class="p">)</span><span class="w">
                </span><span class="n">preds</span><span class="w"> </span><span class="p">(</span><span class="nf">map-set-pairs</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">pairs</span><span class="p">)</span><span class="w">
                </span><span class="n">q1</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">pairs</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="nf">overlaps</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="p">)]</span><span class="w">
              </span><span class="p">(</span><span class="nf">find-paths</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">all</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">q2</span><span class="p">)))</span><span class="w">
          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">find-pairs</span><span class="w"> </span><span class="n">q2</span><span class="w"> </span><span class="n">succs</span><span class="p">)</span><span class="w">
                </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nf">map-set-pairs</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">pairs</span><span class="p">)</span><span class="w">
                </span><span class="n">q2</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">pairs</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nb">if-let</span><span class="w"> </span><span class="p">[</span><span class="n">all</span><span class="w"> </span><span class="p">(</span><span class="nf">overlaps</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">q2</span><span class="p">)]</span><span class="w">
              </span><span class="p">(</span><span class="nf">find-paths</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="p">(</span><span class="nb">set</span><span class="w"> </span><span class="n">all</span><span class="p">))</span><span class="w">
              </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">preds</span><span class="w"> </span><span class="n">succs</span><span class="w"> </span><span class="n">q1</span><span class="w"> </span><span class="n">q2</span><span class="p">))))))))</span><span class="w">
</span></code></pre>

<p>There&rsquo;s a lot of code here, including some optimizations and helper functions.
The important function here is <code>bidirectional-bfs</code>. I won&rsquo;t explain the details
of the algorithm, but at a high level, it takes in a start and end node and a
function to be called on any node to get it&rsquo;s &ldquo;neighbors&rdquo;.</p>

<p>This is a generic, pure function, agnostic of Datomic or our data. In fact, I used
a simple map as the &ldquo;graph&rdquo; while developing this:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">graph</span><span class="w">
  </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="p">]</span><span class="w">
   </span><span class="no">:b</span><span class="w"> </span><span class="p">[</span><span class="no">:a</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="no">:d</span><span class="p">]</span><span class="w">
   </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="no">:e</span><span class="p">]</span><span class="w">
   </span><span class="no">:d</span><span class="w"> </span><span class="p">[</span><span class="no">:b</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="no">:e</span><span class="p">]</span><span class="w">
   </span><span class="no">:e</span><span class="w"> </span><span class="p">[</span><span class="no">:c</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="no">:f</span><span class="p">]</span><span class="w">
   </span><span class="no">:f</span><span class="w"> </span><span class="p">[]})</span><span class="w">

</span><span class="p">(</span><span class="nf">bidirectional-bfs</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="no">:e</span><span class="w"> </span><span class="n">graph</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; [[:a :b :c :e] [:a :b :d :e]]
</span></code></pre>

<p>To use this generic algorithm with our database, we need a <code>neighbors</code> function.
Depending on whether a node is an &ldquo;actor&rdquo; or a &ldquo;movie&rdquo;, we need to return its
appropriate counterpart. A naive &ldquo;or&rdquo; condition is actually good enough here:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">movie-actors</span><span class="w">
  </span><span class="s">"Given a Datomic database value and a movie id,
  returns ids for actors in that movie."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:e</span><span class="w"> </span><span class="p">(</span><span class="nf">d/datoms</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:vaet</span><span class="w"> </span><span class="n">eid</span><span class="w"> </span><span class="no">:actor/movies</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">actor-movies</span><span class="w">
  </span><span class="s">"Given a Datomic database value and an actor id,
  returns ids for movies that actor was in."</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="no">:v</span><span class="w"> </span><span class="p">(</span><span class="nf">d/datoms</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="no">:eavt</span><span class="w"> </span><span class="n">eid</span><span class="w"> </span><span class="no">:actor/movies</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">neighbors</span><span class="w">
  </span><span class="s">"db is database value
  eid is an actor or movie eid"</span><span class="w">
  </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">actor-movies</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">movie-actors</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">eid</span><span class="p">))))</span><span class="w">

</span></code></pre>

<p>Gluing everything together is a simple matter of partial application:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">find-id-paths</span><span class="w"> </span><span class="p">[</span><span class="n">db</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">target</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">bidirectional-bfs</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">neighbors</span><span class="w"> </span><span class="n">db</span><span class="p">)))</span><span class="w">
</span></code></pre>

<p>Given a source entity id and a target entity id, this will return all shortest
paths (ids), much like the query example above. From there, we could map them
to Datomic entities, get their names, or sort the paths using a domain-specific
heuristic. Plugging in the previous example, we might do something like the
following:</p>
<pre><code class="highlight clojure"><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">db</span><span class="w"> </span><span class="n">conn</span><span class="p">)</span><span class="w">
      </span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">d/filter</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">(</span><span class="nf">without-documentaries</span><span class="w"> </span><span class="n">d</span><span class="p">))</span><span class="w">
      </span><span class="n">biebs</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entid</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">[</span><span class="no">:actor/name</span><span class="w"> </span><span class="s">"Bieber, Justin"</span><span class="p">])</span><span class="w">
      </span><span class="n">bacon</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entid</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="p">[</span><span class="no">:actor/name</span><span class="w"> </span><span class="s">"Bacon, Kevin (I)"</span><span class="p">])</span><span class="w">
      </span><span class="nb">name</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">actor-or-movie-name</span><span class="w"> </span><span class="n">d</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">mapv</span><span class="w"> </span><span class="nb">name</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">find-id-paths</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">biebs</span><span class="w"> </span><span class="n">bacon</span><span class="p">)))</span><span class="w">
</span><span class="c1">;=&gt; (["Bieber, Justin" "Men in Black 3 (2012)" "Jones, Tommy Lee" "JFK (1991)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Segal, Tobias" "R.I.P.D. (2013)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Brolin, Josh" "Hollow Man (2000)" "Bacon, Kevin (I)"] ["Bieber, Justin" "Men in Black 3 (2012)" "Howard, Rosemary (II)" "R.I.P.D. (2013)" "Bacon, Kevin (I)"])
</span></code></pre>

<p>This returns the same set of paths as the query method did. However, this
version has the advantage of going to an arbitrary depth.</p>

<p>This is just one example of graph searching with Datomic. Different kinds of
problems and domains could use other algorithms. The idea, though, is that
generic graph searching functions can be used directly, since the data is
effectively local to the peer machine.</p>

<p>For more Clojure implementations of generic graph searching algorithms,
<a href="https://github.com/aysylu/loom">loom&rsquo;s</a> <a href="https://github.com/aysylu/loom/blob/master/src/loom/alg_generic.clj">alg_generic</a> namespace is a great starting point.</p>

<h2>Performance</h2>

<p>I&rsquo;m using the above ideas and functions on IMDB&rsquo;s dataset to power
the project. Once the peer&rsquo;s index caches are warmed, the performance
is quite good: most searches I&rsquo;ve performed between well-known actors complete
in under a second, and in many cases, under 100 ms. I never got results that
good with Neo4j&rsquo;s cypher query language.</p>

<h2>Source</h2>

<p>The code in this post is based on the <a href="https://github.com/jgdavey/kevin">source</a>.</p>
]]>
    </content>
  </entry>
  <entry>
    <title>
      <![CDATA[Deferring constraints in PostgreSQL]]>
    </title>
    <link rel="alternate" href="http://joshuadavey.com/2013/08/22/deferring-database-constraints/"/>
    <id>http://joshuadavey.com/2013/08/22/deferring-database-constraints/</id>
    <published>2013-08-21T20:00:00-04:00</published>
    <updated>2018-07-02T09:35:59-04:00</updated>
    <author>
      <name>Joshua Davey</name>
    </author>
    <content type="html">
      <![CDATA[<p><em>This is a repost. You can find the original <a title="Deferring constraints in PostgreSQL" href="http://hashrocket.com/blog/posts/deferring-database-constraints">here</a></em></p>

<p>Database constraints are essential to ensuring data integrity, and you
should use them. Allowing them to be deferrable during transactions
makes them even more convenient. A common scenario in which the database
can help us is in a sortable list implementation. This post outlines
the how and why of deferring database constraints, using a sortable list
domain as an example.</p>

<h1>Modeling lists of sortable items</h1>

<p>Imagine that you have an application with multiple lists. Each list has
items that can be reordered with a drag-and-drop interaction. This can
be modelled in a fairly straightforward manner.</p>

<p>Each list <code>has_many</code> list items, which are ordered by the <code>position</code>
column. Each list&rsquo;s items have a position beginning with 1 and
incrementing with each subsequent item.</p>
<pre><code class="highlight ruby"><span class="c1"># app/models/list.rb</span>
<span class="k">class</span> <span class="nc">List</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:items</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">order</span> <span class="ss">:position</span> <span class="p">},</span> <span class="ss">class_name: </span><span class="s2">"ListItem"</span>
  <span class="n">validates_presence_of</span> <span class="ss">:name</span>
<span class="k">end</span>
</code></pre>
<pre><code class="highlight ruby"><span class="c1"># app/models/list_item.rb</span>
<span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:list</span>
  <span class="n">validates_presence_of</span> <span class="ss">:name</span><span class="p">,</span> <span class="ss">:list</span><span class="p">,</span> <span class="ss">:position</span>

  <span class="n">before_validation</span> <span class="ss">:ensure_position</span>

  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
      <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">ensure_position</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">position</span> <span class="o">||=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">list_id: </span><span class="n">list_id</span><span class="p">).</span><span class="nf">maximum</span><span class="p">(</span><span class="ss">:position</span><span class="p">).</span><span class="nf">to_i</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>A couple things are worth noting about the <code>ListItem</code> class. Firstly, we
have <code>update_positions</code>, a class method that accepts an array of ids and
updates each. This method will be called in a <code>sort</code> controller action
as such:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ItemsController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">expose</span><span class="p">(</span><span class="ss">:list</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sort</span>
    <span class="c1"># list item ids is an ordered array of ids</span>
    <span class="n">list</span><span class="p">.</span><span class="nf">items</span><span class="p">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">params</span><span class="o">[</span><span class="ss">:list_item_ids</span><span class="o">]</span><span class="p">)</span>
    <span class="n">head</span> <span class="ss">:ok</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Secondly, new items don&rsquo;t necessarily know what position they should
have, so we put list items that don&rsquo;t have <code>position</code> at the end of
their respective list, just before validating that the position is
present.</p>

<p>Here are the migrations that we used to create the models&#39; database
tables:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateLists</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:lists</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">CreateListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">create_table</span> <span class="ss">:list_items</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">belongs_to</span> <span class="ss">:list</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="ss">:position</span>
      <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="ss">:name</span>

      <span class="n">t</span><span class="p">.</span><span class="nf">timestamps</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Notice anything missing? If you said database constraints, you&rsquo;re
correct! Our application is enforcing presence for most attributes, but
our corresponding columns are missing <code>NOT NULL</code> constraints. Also, the
<code>list_id</code> column on <code>list_items</code> is missing a foreign key constraint.</p>

<p>But I&rsquo;d like to focus on another missing constraint. Our domain model has
an implicit requirement that we haven&rsquo;t enforced with either validations
or database constraints: each list item&rsquo;s position should be <em>unique per
list</em>. No two list items in a list should have the same position. That
would make the ordering non-deterministic.</p>

<p>We could add a uniqueness validation for <code>position</code>, scoped to
the <code>list_id</code>. However, as <a title="The Perils of Uniqueness Validations" href="http://robots.thoughtbot.com/post/55689359336/the-perils-of-uniqueness-validations">thoughtbot recently warned</a>,
application-level uniqueness validations are insufficient <em>at best</em>, and
fail completely in concurrent environments.</p>

<p>The <code>position</code> column needs a database-level constraint.</p>

<h1>Adding constraints</h1>

<p>Adding the uniqueness constraint to <code>position</code> is fairly straightforward
in PostgreSQL. We&rsquo;ll just create a new migration with the following:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">AddUniquenessValidationOnListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        add constraint list_item_position unique (list_id, position);
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        drop constraint if exists list_item_position;
</span><span class="no">    SQL</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Let&rsquo;s wrap our <code>UPDATE</code> statements in a transaction so that any failed
<code>UPDATE</code> of the position column will result in none of them being
updated:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This ensures at the database level that positions of items are unique
per list; no two items in the same list can occupy the &ldquo;1&rdquo; position.
With regard to data integrity, this is a huge improvement over our
initial implementation. But it has one drawback: <strong>it doesn&rsquo;t work</strong>.</p>

<p>To illustrate why, imagine a list with the following items:</p>
<pre><code class="highlight plaintext">id | position | name
13 | 1        | Eggs
18 | 2        | Milk
35 | 3        | Bread
</code></pre>

<p>To move Bread to the top of the list, we would pass an array of ids,
<code>[35,13,18]</code> to the <code>update_positions</code> method. This method does a series
of <code>UPDATE</code> statements to the database. For the first id, the one for
Bread, we end up sending an update statement that would look like the
following:</p>
<pre><code class="highlight sql"><span class="k">UPDATE</span> <span class="n">list_items</span> <span class="k">SET</span> <span class="k">position</span><span class="o">=</span><span class="mi">1</span> <span class="k">WHERE</span> <span class="n">id</span><span class="o">=</span><span class="mi">35</span><span class="p">;</span>
</code></pre>

<p>After this statement is executed in the database, but before we move on
to the next id in the list, Postgres will fail its constraint checks. At
the moment that the <code>UPDATE</code> happens, the data would be:</p>
<pre><code class="highlight plaintext">id | position | name
13 | 1        | Eggs
18 | 2        | Milk
35 | 1        | Bread
</code></pre>

<p>With both Eggs and Bread occupying the same position, the <code>UPDATE</code> fails.
Of course, we know that we want to change the position of Eggs as well,
so that its position would be &ldquo;2&rdquo;, and that collision would not happen.
But at the time that the constraint-check happens, the database doesn&rsquo;t
know this.</p>

<p>Even within a transaction, database uniqueness constraints are enforced
immediately <strong>per row</strong>. It seems our dreams of data integrity are
smashed. If only there were a way to enforce uniqueness constraints at
the end of the transaction, rather than the end of each statement&hellip;</p>

<h1>Deferrable Constraints</h1>

<p>As mentioned before, constraints are immediately enforced. This
behavior can be changed within a transaction by changing a constraints
deferrable characteristics. In PostgreSQL, constraints are assumed to
be <code>NOT DEFERRABLE</code> by default.</p>

<p>However, constraints can also behave as deferrable in one of two ways:
<code>DEFERRABLE INITIALLY IMMEDIATE</code> or <code>DEFERRABLE INITIALLY DEFERRED</code>.
The first part, <code>DEFERRABLE</code>, is what allows the database constraint
behavior to change within transactions. The second part describes what
the default behavior will be within a transaction.</p>

<p>With a constraint that is deferrable, but initially immediate, the
constraint will by default behave just like a non-deferrable constraint,
checking every statement immediately. A constraint that is initially
deferred will, by default, defer its checks until the transaction is
committed. Both of these can change their behavior per-transaction with a
call to <code>SET CONSTRAINTS</code> (<a href="http://www.postgresql.org/docs/9.2/static/sql-set-constraints.html">documentation</a>).</p>

<p>With that information, let&rsquo;s change the definition of the constraint we
defined before:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">AddUniquenessValidationOnListItems</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span>
  <span class="k">def</span> <span class="nf">up</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        add constraint list_item_position unique (list_id, position)
        DEFERRABLE INITIALLY IMMEDIATE;
</span><span class="no">    SQL</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">down</span>
    <span class="n">execute</span> <span class="o">&lt;&lt;-</span><span class="no">SQL</span><span class="sh">
      alter table list_items
        drop constraint if exists list_item_position;
</span><span class="no">    SQL</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>The only thing we&rsquo;ve changed from before is the <code>DEFERRABLE INITIALLY
IMMEDIATE</code> bit. I think it is a good idea to use the <code>INITIALLY
IMMEDIATE</code> option. This will ensure that other parts of our app, and
other consumers of the database will not be surprised by the behavior of
the constraint; it will continue to act a like a normal, non-deferrable
constraint, until we explicitly opt in to the deferral.</p>

<p>We now need to change our transaction block. In our case, the first
database statement within the transaction must be the <code>SET CONSTRAINTS</code>
statement:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">connection</span><span class="p">.</span><span class="nf">execute</span> <span class="s2">"SET CONSTRAINTS list_item_position DEFERRED"</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Having now opted in to deferring our uniqueness constraint, reordering
the items now works as expected. The constraint still ensures that we
don&rsquo;t have two items that occupy the same position, but waits until the
end of the transaction to do that check. We can have our data integrity
cake and eat it too.</p>

<h1>Bonus: deferrable introspection</h1>

<p>Having to name the constraint in two places is a bit of a bummer, and
introduces a coupling that could bite us if the constraint name ever
changed. Knowing that, we leverage PostgreSQL&rsquo;s introspective abilities
to query the constraint names instead.</p>

<p>For example, we can add the following module to our codebase:</p>
<pre><code class="highlight ruby"><span class="c1"># lib/deferrable.rb</span>
<span class="k">module</span> <span class="nn">Deferrable</span>
  <span class="k">def</span> <span class="nf">deferrable_uniqueness_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>
    <span class="n">usage</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'information_schema.constraint_column_usage'</span>
    <span class="n">constraint</span> <span class="o">=</span> <span class="no">Arel</span><span class="o">::</span><span class="no">Table</span><span class="p">.</span><span class="nf">new</span> <span class="s1">'pg_constraint'</span>
    <span class="n">arel</span> <span class="o">=</span> <span class="n">usage</span><span class="p">.</span><span class="nf">project</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:constraint_name</span><span class="o">]</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">constraint</span><span class="p">).</span><span class="nf">on</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:constraint_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:conname</span><span class="o">]</span><span class="p">))</span>
    <span class="p">.</span><span class="nf">where</span><span class="p">(</span>
      <span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:contype</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="s1">'u'</span><span class="p">))</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">constraint</span><span class="o">[</span><span class="ss">:condeferrable</span><span class="o">]</span><span class="p">)</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:table_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">table_name</span><span class="p">))</span>
      <span class="p">.</span><span class="nf">and</span><span class="p">(</span><span class="n">usage</span><span class="o">[</span><span class="ss">:column_name</span><span class="o">]</span><span class="p">.</span><span class="nf">eq</span><span class="p">(</span><span class="n">column_name</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">connection</span><span class="p">.</span><span class="nf">select_values</span> <span class="n">arel</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">transaction_with_deferred_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">)</span>
    <span class="n">transaction</span> <span class="k">do</span>
      <span class="n">constraints</span> <span class="o">=</span> <span class="n">deferrable_uniqueness_constraints_on</span><span class="p">(</span><span class="n">column_name</span><span class="p">).</span><span class="nf">join</span> <span class="s2">","</span>
      <span class="n">connection</span><span class="p">.</span><span class="nf">execute</span><span class="p">(</span><span class="s2">"SET CONSTRAINTS %s DEFERRED"</span> <span class="o">%</span> <span class="n">constraints</span><span class="p">)</span>
      <span class="k">yield</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>And now change our model to use it:</p>
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">ListItem</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">extend</span> <span class="no">Deferrable</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">update_positions</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="n">transaction_with_deferred_constraints_on</span><span class="p">(</span><span class="ss">:position</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">ids</span><span class="p">.</span><span class="nf">each_with_index</span> <span class="k">do</span> <span class="o">|</span><span class="nb">id</span><span class="p">,</span> <span class="n">index</span><span class="o">|</span>
        <span class="n">where</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">id</span><span class="p">).</span><span class="nf">update_all</span><span class="p">(</span><span class="ss">position: </span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>And, boom! Less coupling.</p>

<p><strong>NOTE</strong> That&rsquo;s a lot of Arel! Use at your own risk. ;-)</p>

<h1>Example application</h1>

<p>While writing this post, I created a <a href="https://github.com/jgdavey/uniqueness_constraints_example">sample Rails app</a> to iterate
quickly. I used TDD to write the initial approach, and reused the specs
while I &ldquo;refactored&rdquo; the implementation to the subsequent approaches.
Each <a href="https://github.com/jgdavey/uniqueness_constraints_example/commits/master">commit on the master branch</a> more or less follows the
sections above.</p>
]]>
    </content>
  </entry>
</feed>
